SQL语句-查询语句-单行函数

查询语句DQL简介

select * | {[distinct] column | expression [alias] , ...}
from table;

    select 后面跟 通配符|关键字|表达式 别名 或者一些计算
    from 后面跟 表名 或者 结果集 ，这就是oracle对国标扩展的部分，能够对结果集进行二次查询
    必须要有结束符号 ;有结束符，sql才会被运行
    大小写不区分
    可以多行书写

简单的sql查询
简单的sql查询 	语句
查看scott用户下有哪些表和视图 	SQL> select * from tab;
描述一张表的结构，不看表中的数据 	SQL> desc dept
查看雇员表中的所有数据 	select * from dept;
描述雇员表的结构 	SQL> desc emp
查看emp表中感兴趣的列 	SQL> select ename,sal from emp;
在select中使用四则运算:null不能参与四则运算 	select ename,(sal+100)*12 from emp;
为列定义别名 	select ename AS first_name,sal*12 "Annual Salary" from emp;
连接操作符 	select ename,job,ename||' is a '||job detail from emp;
压缩重复行 	select distinct deptno,job from emp;
将缓冲区中的命令保存为脚本 	SQL> save p1_1.sql
查看sql脚本内容 	SQL> get p1_1.sql
运行sql脚本 	SQL> @p1_1.sql

sqlplus结果集的显示风格为:

    字符串和日期类型左对齐
    数字类型右对齐
    缺省显示为大写

SQL> SELECT * FROM TAB;

TNAME			       TABTYPE	CLUSTERID
------------------------------ ------- ----------
BONUS			       TABLE
DEPT			       TABLE
EMP			       TABLE
SALGRADE		       TABLE

SQL> desc dept;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 DEPTNO 				   NOT NULL NUMBER(2)
 DNAME						    VARCHAR2(14)
 LOC						    VARCHAR2(13)

SQL> select * from dept;

    DEPTNO DNAME	  LOC
---------- -------------- -------------
	10 ACCOUNTING	  NEW YORK
	20 RESEARCH	  DALLAS
	30 SALES	  CHICAGO
	40 OPERATIONS	  BOSTON

SQL> select ename,sal from emp;

ENAME		  SAL
---------- ----------
SMITH		  800
ALLEN		 1600
WARD		 1250
JONES		 2975
MARTIN		 1250
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
TURNER		 1500
ADAMS		 1100

ENAME		  SAL
---------- ----------
JAMES		  950
FORD		 3000
MILLER		 1300

14 rows selected.

SQL> select ename,(sal+100)*12 from emp;

ENAME	   (SAL+100)*12
---------- ------------
SMITH		  10800
ALLEN		  20400
WARD		  16200
JONES		  36900
MARTIN		  16200
BLAKE		  35400
CLARK		  30600
SCOTT		  37200
KING		  61200
TURNER		  19200
ADAMS		  14400

ENAME	   (SAL+100)*12
---------- ------------
JAMES		  12600
FORD		  37200
MILLER		  16800

14 rows selected.

-- (SAL+100)*12列在磁盘上并没有保存，我们称其为计算表达式所生成的伪列
-- 空值不能参与运算
SQL> select ename,sal,comm,sal+comm from emp;

ENAME		  SAL	    COMM   SAL+COMM
---------- ---------- ---------- ----------
SMITH		  800
ALLEN		 1600	     300       1900
WARD		 1250	     500       1750
JONES		 2975
MARTIN		 1250	    1400       2650
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
TURNER		 1500	       0       1500
ADAMS		 1100

ENAME		  SAL	    COMM   SAL+COMM
---------- ---------- ---------- ----------
JAMES		  950
FORD		 3000
MILLER		 1300

14 rows selected.

-- 将工资和奖金求和，结果发现奖金comm列为null的员工不用发工资了！这是错误的

SQL> select ename as first_name , sal*12 "Annual Salary" from emp;    

FIRST_NAME Annual Salary
---------- -------------
SMITH		    9600
ALLEN		   19200
WARD		   15000
JONES		   35700
MARTIN		   15000
BLAKE		   34200
CLARK		   29400
SCOTT		   36000
KING		   60000
TURNER		   18000
ADAMS		   13200

FIRST_NAME Annual Salary
---------- -------------
JAMES		   11400
FORD		   36000
MILLER		   15600

14 rows selected.

-- as可以省略，如果别名加了引号，则显示指定的字符，而不会使用缺省的大写

SQL> select ename,job,ename || ' is a ' || job detail from emp;

ENAME	   JOB	     DETAIL
---------- --------- -------------------------
SMITH	   CLERK     SMITH is a CLERK
ALLEN	   SALESMAN  ALLEN is a SALESMAN
WARD	   SALESMAN  WARD is a SALESMAN
JONES	   MANAGER   JONES is a MANAGER
MARTIN	   SALESMAN  MARTIN is a SALESMAN
BLAKE	   MANAGER   BLAKE is a MANAGER
CLARK	   MANAGER   CLARK is a MANAGER
SCOTT	   ANALYST   SCOTT is a ANALYST
KING	   PRESIDENT KING is a PRESIDENT
TURNER	   SALESMAN  TURNER is a SALESMAN
ADAMS	   CLERK     ADAMS is a CLERK

ENAME	   JOB	     DETAIL
---------- --------- -------------------------
JAMES	   CLERK     JAMES is a CLERK
FORD	   ANALYST   FORD is a ANALYST
MILLER	   CLERK     MILLER is a CLERK

14 rows selected.

-- ||是字符连接符 detail是别名

SQL> select distinct deptno,job from emp;

    DEPTNO JOB
---------- ---------
	20 CLERK
	30 SALESMAN
	20 MANAGER
	30 CLERK
	10 PRESIDENT
	30 MANAGER
	10 CLERK
	10 MANAGER
	20 ANALYST

9 rows selected.

-- distinct 去除重复

SQL> save p1_1.sql
Created file p1_1.sql
SQL> get p1_1.sql
  1* select distinct deptno,job from emp
SQL> @p1_1.sql

    DEPTNO JOB
---------- ---------
	20 CLERK
	30 SALESMAN
	20 MANAGER
	30 CLERK
	10 PRESIDENT
	30 MANAGER
	10 CLERK
	10 MANAGER
	20 ANALYST

9 rows selected.

限制和排列数据

    工资高于1500的销售员？
    查询10部门的雇员和20部门工资小与2000的雇员？
    查询有奖金的雇员？
    使用rownum伪列限制查询返回的行的数量

SQL> select ename,sal from emp where sal>1500;

ENAME		  SAL
---------- ----------
ALLEN		 1600
JONES		 2975
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
FORD		 3000

7 rows selected.

SQL> select deptno,ename,sal from emp where (deptno=10 or deptno=20) and sal < 2000;

    DEPTNO ENAME	     SAL
---------- ---------- ----------
	20 SMITH	     800
	20 ADAMS	    1100
	10 MILLER	    1300

SQL> select deptno,ename,sal from emp where deptno in (10,20) and sal < 2000;

    DEPTNO ENAME	     SAL
---------- ---------- ----------
	20 SMITH	     800
	20 ADAMS	    1100
	10 MILLER	    1300

SQL> select ename,comm from emp where comm is not null;

ENAME		 COMM
---------- ----------
ALLEN		  300
WARD		  500
MARTIN		 1400
TURNER		    0

SQL> select ename from emp where rownum < 6;

ENAME
----------
SMITH
ALLEN
WARD
JONES
MARTIN

-- mysql中限制行是用limit，而oracle用rownum

单行函数

    五种：字符函数、数值函数、日期函数、转换函数、其他函数

字符函数
字符串函数 	函数名 	解释
大小写转换 	LOWER(column or expression) 	小写
	UPPER(column or expression) 	把字母全部变成大写
	INITCAP(column or expression) 	首字母大写
字符处理 	CONCAT(column1 or expression1,column2|expression2) 	连接字符
	SUBSTR(column or expression,m[,n]) 	截取从索引位m的字符开始的数量为n个的字符，索引从1开始
	LENGTH(column or expression) 	返回字符串长度
	INSTR(column or expression,‘string’, [,m], [n] ) 	返回字符串的位置。你可以随机地指定从第 m 个字母开始搜索第 n 个要查找的字符串。m 和 n 缺省为 1, 意思是从第一个字母开始查找第一次出现要查找的字符串的位置。
	LPAD(column or expression, n,'string') 	右对齐字符串,左面用指定字符填充至 n位;
	RPAD(column or expression, n,'string') 	左对齐字符串,右边用指定字符填充至 n位
	TRIM(leading or trailing or both, trim_character FROM trim_source) 	删除头尾字符，默认为空白，类似于python中strim
	REPLACE(text,search_string,replacement_string) 	查找并替换字符串
字符函数示例

    记录中的字符串是区分大小写，如果想从海量数据中搜索scott用户，该如何去做呢？

select * from emp where lower(ename)='scott';

究竟用lower还是upper，需要规范前端应用程序，如果小写就都小写，要大写就都大写，函数的选择影响索引的创建，代码的书写规则影响后面索引的创建。

    instr和substr的区别 instr为指定一个字符获取该字符在目标字符串的位置 substr为截取制定索引位的字符串 将两者结合在一起用，比如打印字符串中第一个a和第二个a之间的字符串，包含第一个a

SQL> select instr('abca','a') from dual;

INSTR('ABCA','A')
-----------------
		1

SQL> select instr('abca','a',2) from dual;

INSTR('ABCA','A',2)
-------------------
		  4

SQL> select substr('abca',1,4-1) from dual;

SUB
---
abc

SQL> select instr('superman batman wonderwoman','batman') from dual;

INSTR('SUPERMANBATMANWONDERWOMAN','BATMAN')
-------------------------------------------
					 10
-- 截取字符串'superman batman wonderwoman'中从batman开始到最后

SQL> select substr('superman batman wonderwoman',instr('superman batman wonderwoman','batman')) from dual;

SUBSTR('SUPERMANBA
------------------
batman wonderwoman

    填充，打印固定字符，实现左右对齐

SQL> select lpad('abc',6,'*') from dual;

LPAD('
------
***abc

SQL> select rpad('abc',6,'*') from dual;

RPAD('
------
abc***

    删除字符串 ab 前后空白

SQL> select trim('  abc  ') from dual;

TRI
---
abc

SQL> select '  abc  ' from dual;

'ABC'
-------
  abc

一般空格在左边容易发现，空格在右边不容易发现，默认取出的半角的，所以最好再来一次全角的空格。

例如，从emp中查找雇员名为scott的详细信息

SQL> insert into emp values (1111,'SCoTT ','ANALYST',7566,'19-APR-87',3000,20,NULL);

1 row created.

SQL> select * from emp where lower(ename)='scott';

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3000 		   20

SQL> select * from emp where trim(lower(ename))='scott';

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      1111 SCoTT      ANALYST	      7566 19-APR-87	   3000 	20
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3000 		   20

SQL> select * from emp where trim(' ' from trim(lower(ename)))='scott';

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      1111 SCoTT      ANALYST	      7566 19-APR-87	   3000 	20
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3000 		   20

trim只能带一个字符

    替换字符串

SQL> select replace('superman batman wonderwoman','batman','booboo') from dual;

REPLACE('SUPERMANBATMANWOND
---------------------------
superman booboo wonderwoman

    显示姓氏的最后一个字母是n的那些雇员的相应资料:

SQL> select ename from emp where substr(lower(ename),instr(lower(ename),'n',-1)) = 'n' ;

ENAME
----------
ALLEN
MARTIN

SQL> select ename from emp where lower(ename) like '%n';

ENAME
----------
ALLEN
MARTIN

    执行以下sql并解释的含义

select concat('Hello','World') from dual;
select concat(ename,job) from emp;
select substr('Helloworld',1,2) from dual;
select substr('Helloworld',5) from dual;
select substr('Helloworld',-5,2) from dual;
select length('Helloworld') from dual;
select instr('Helloworld','l') from dual;
select instr('Helloworld','l',1,2) from dual;
select instr('Helloworld','l',-1,2) from dual;
select instr('Helloworld','l',-1) from dual;
select lpad('Hello',10,'*') from dual;
select rpad('Hello',10,'*') from dual;
select trim('H' from 'HelloHhHH') from dual;
select * from emp where trim(' ' from UPPER(ename))='SCOTT';
select replace('Helloworld','owo','xxoo') from dual;

数值函数

    ROUND :将值舍入到指定的小数位
    TRUNC :将值截断到指定的小数位
    MOD :返回除法运算的余数

DUAL 是可用于查看函数和计算结果的公用表。

执行以下sql并解释的含义

select round(45.926,2) from dual;
select round(45.926,0) from dual;
select round(45.926) from dual;
select round(45.926,-1) from dual;

select trunc(45.926,2) from dual;
select trunc(45.926,0) from dual;
select trunc(45.926) from dual;
select trunc(45.926,-1) from dual;

select mod(15,4) from dual;
select power(3,3) from dual;
select ceil(1.00001) from dual;
select abs(-190) from dual;

日期函数

日期是以数字保存的，可以进行加减运算
函数 	结果
MONTHS_BETWEEN 	两个日期之间的月数
ADD_MONTHS 	将指定的月数添加到日期
NEXT_DAY 	指定日期之后的下一个日期
LAST_DAY 	当月最后一天
ROUND 	舍入日期
TRUNC 	截断日期
MONTHS_BETWEEN('01-SEP-95','11-JAN-94') 	19.6774194
ADD_MONTHS ('31-JAN-96',1) 	'29-FEB-96'
NEXT_DAY ('01-SEP-95','FRIDAY') 	'08-SEP-95'
LAST_DAY ('01-FEB-95') 	'28-FEB-95'

    计算每一个雇员工作的时间（天）

    sysdate返回当前时间
    hiredate雇员入职时间

SQL> select sysdate from dual;

SYSDATE
---------
29-JUN-17

SQL> select sysdate - hiredate from emp;

SYSDATE-HIREDATE
----------------
      11029.7991
      13343.7991
      13278.7991
      13276.7991
      13237.7991
      13058.7991
      13208.7991
      13169.7991
      11029.7991
      13008.7991
      13078.7991
      10995.7991
      12992.7991
      12992.7991
      12941.7991

15 rows selected.

这里计算的结果为天数

    计算每个雇员工作的时间，单位为月

    months_between() 计算两个时间点间的月数

SQL> select ename,months_between(sysdate,hiredate) from emp;

ENAME	   MONTHS_BETWEEN(SYSDATE,HIREDATE)
---------- --------------------------------
SCoTT				 362.348474
SMITH				  438.41299
ALLEN				 436.316216
WARD				   436.2517
JONES				 434.896861
MARTIN				 429.058152
BLAKE				 433.929119
CLARK				 432.671055
SCOTT				 362.348474
KING				  427.41299
TURNER				 429.703313
ADAMS				 361.219442
JAMES				 426.864603
FORD				 426.864603
MILLER				 425.219442

15 rows selected.

    假设员工使用期都是三个月，查看员工专正日期

    add_months() 在制定时间点上加多少个月份

SQL> select ename,hiredate,add_months(hiredate,3)  from emp;

ENAME	   HIREDATE  ADD_MONTH
---------- --------- ---------
SCoTT	   19-APR-87 19-JUL-87
SMITH	   17-DEC-80 17-MAR-81
ALLEN	   20-FEB-81 20-MAY-81
WARD	   22-FEB-81 22-MAY-81
JONES	   02-APR-81 02-JUL-81
MARTIN	   28-SEP-81 28-DEC-81
BLAKE	   01-MAY-81 01-AUG-81
CLARK	   09-JUN-81 09-SEP-81
SCOTT	   19-APR-87 19-JUL-87
KING	   17-NOV-81 17-FEB-82
TURNER	   08-SEP-81 08-DEC-81
ADAMS	   23-MAY-87 23-AUG-87
JAMES	   03-DEC-81 03-MAR-82
FORD	   03-DEC-81 03-MAR-82
MILLER	   23-JAN-82 23-APR-82

15 rows selected.

    这周六是哪一天？本月最后一天是那一天？

    next_day() 用周几的方式来表示将来的某一天
    last_day() 指定时间点所在月份的最后一天，返回自然月的最后一天

    Last_day()快速定位自然月最后一天，还有什么用？可以计算期末量。

    例如：每个月月底库存还剩下多少？月底销售员的销售额是多少？

    同比：今年二月份比去年二月份有什么变化？

    环比：今年二月份和今年一月份有什么变化？

    分析出淡季旺季

    同期比：

SQL> select sysdate from dual;

SYSDATE
---------
29-JUN-17

SQL> select next_day(sysdate,'sun') as SUN ,last_day(sysdate) Last from dual;

SUN	  LAST
--------- ---------
02-JUL-17 30-JUN-17

    生日所在那个月的最后一天

SQL> select last_day(to_date('1990-04-15','yyyy-mm-dd')) from dual;

LAST_DAY(
---------
30-APR-90

SQL> select last_day(to_date('1900-02-15','yyyy-mm-dd')) from dual;

LAST_DAY(
---------
28-FEB-00

每四年会多23小时48分钟xx秒，差了十几分钟，这样累计400年我们就丢了一天，这一天算到哪里去呢？

就在1900年就不算闰年，（能被100整除，还能被400整除）

还可以用来计算自然月的月底销售人员的销售额

期末量、期初量、同比、环比

    日期只显示年或者月

round() 四舍五入 trunc() 截断日期

'year': <=6月 舍弃，> 6月 进

'month': <=15天 舍弃，> 15天 进

SQL> select sysdate from dual;

SYSDATE
---------
29-JUN-17

SQL> select round(sysdate,'year') from dual;

ROUND(SYS
---------
01-JAN-17

SQL> select round(sysdate+30,'year') from dual;

ROUND(SYS
---------
01-JAN-18

SQL> select round(sysdate,'month') from dual;

ROUND(SYS
---------
01-JUL-17

SQL> select round(sysdate-15,'month') from dual;

ROUND(SYS
---------
01-JUN-17


SQL> select round(sysdate-15,'month') from dual;

ROUND(SYS
---------
01-JUN-17

SQL> select to_date('2017-07-16','yyyy-mm-dd') from dual;

TO_DATE(
---------
16-JUL-17

SQL> select round(to_date('2017-07-16','yyyy-mm-dd'),'year') from dual;

ROUND(TO_
---------
01-JAN-18

SQL> select trunc(to_date('2017-07-16','yyyy-mm-dd'),'year') from dual;

TRUNC(TO_
---------
16-JAN-17

SQL> select round(to_date('2017-07-16','yyyy-mm-dd'),'month') from dual;

ROUND(TO_
---------
01-AUG-17

SQL> select trunc(to_date('2017-07-16','yyyy-mm-dd'),'month') from dual;

TRUNC(TO_
---------
01-JUL-17

    执行以下sql并解释的含义

select sysdate from dual;
select sysdate,sysdate+1/1440 from dual;
select months_between(sysdate,hiredate),ename from emp;
select sysdate,add_months(sysdate,6) from dual;
select sysdate,next_day(sysdate,'wed') from dual;
select sysdate,last_day(to_date('01-feb-1900','dd-mon-yyyy')) from dual;
select round(sysdate,'month') from dual;
select round(sysdate,'year') from dual;
select trunc(sysdate,'month') from dual;
select trunc(sysdate,'year') from dual;

转换函数

数据类型转化分为两种：

    隐式数据类型转换 系统自己能作的比较简单的，例如数字变字符串之类的
    显示数据类型转换 必须通过函数，你来制定规则

隐式数据类型转换

Oracle服务器可以自动转换下面的数据类型

    number<--->varchar2|char<---->date

显式数据类型转换

num----------------------------->char---------------------------->date

			to_char(num,'$9.00')		to_date(char,'YYYY-MM-DD')

num<-----------------------------char<-----------------------------date

to_number(char,'L99.00') to_char(date,'YYYY-MM-DD')

    date to_char

TO_CHAR(date, 'format_model')

日期格式样式的元素
元素 	结果
YYYY 	用数字表示的完整年份
YEAR 	拼写出的年份(用英文表示)
MM 	月份的两位数值
MONTH 	月份的完整名称
MON 	月份的三个字母缩写
DY 	一周中某日的三个字母缩写
DAY 	一周中某日的完整名称
DD 	用数字表示的月份中某日
W 	星期几
HH 	小时
MI 	分钟
SS 	秒

SQL> select to_char(sysdate,'YYYY-MM-DD') from dual;

TO_CHAR(SY
----------
2017-07-03

select to_char(sysdate,'YYYYMMDD W HH24:MI:SS') from dual; 

SQL> select to_char(sysdate,'year-month-day') from dual;

TO_CHAR(SYSDATE,'YEAR-MONTH-DAY')
--------------------------------------------------------------
twenty seventeen-july	  -monday

SQL> select to_char(sysdate,'year-month-dy') from dual;

TO_CHAR(SYSDATE,'YEAR-MONTH-DY')
--------------------------------------------------------
twenty seventeen-july	  -mon

SQL> select to_char(sysdate,'dd-mon-rr') from dual;

TO_CHAR(S
---------
03-jul-17

SQL> select to_char(hiredate,'yyyy-mm-dd') from emp;

TO_CHAR(HI
----------
1987-04-19
1980-12-17
1981-02-20
1981-02-22
1981-04-02
1981-09-28
1981-05-01
1981-06-09
1987-04-19
1981-11-17
1981-09-08
1987-05-23
1981-12-03
1981-12-03
1982-01-23

15 rows selected.

SQL> select to_char(hiredate,'dd-mm-yy') from emp;

TO_CHAR(
--------
19-04-87
17-12-80
20-02-81
22-02-81
02-04-81
28-09-81
01-05-81
09-06-81
19-04-87
17-11-81
08-09-81
23-05-87
03-12-81
03-12-81
23-01-82

15 rows selected.

SQL> select hiredate from emp;

HIREDATE
---------
19-APR-87
17-DEC-80
20-FEB-81
22-FEB-81
02-APR-81
28-SEP-81
01-MAY-81
09-JUN-81
19-APR-87
17-NOV-81
08-SEP-81
23-MAY-87
03-DEC-81
03-DEC-81
23-JAN-82

15 rows selected.

日期的后台保存是，前置0+世纪+年+月+日

    number to_char

TO_CHAR(number, 'format_model')

下面列出了一些格式元素,可以将其与 TO_CHAR 函数配合使用,以便将数字值显示为字符:
元素 	结果
9 	代表一个数字
0 	强制显示零
$ 	放置一个浮动的美元符号
L 	使用浮动的本地货币符号
. 	显示小数点
, 	显示作为千位指示符的逗号

-- 将数字以指定格式打印出来

SQL> select ename,to_char(sal,'L99,999.99') as sal from emp;

ENAME	   SAL
---------- --------------------
SCoTT		      $3,000.00
SMITH			$800.00
ALLEN		      $1,600.00
WARD		      $1,250.00
JONES		      $2,975.00
MARTIN		      $1,250.00
BLAKE		      $2,850.00
CLARK		      $2,450.00
SCOTT		      $3,000.00
KING		      $5,000.00
TURNER		      $1,500.00
ADAMS		      $1,100.00
JAMES			$950.00
FORD		      $3,000.00
MILLER		      $1,300.00

15 rows selected.

-- 00和99的区别在整数会前置0补满指定位数

SQL> select ename,to_char(sal,'L00,000.00') as sal from emp;

ENAME	   SAL
---------- --------------------
SCoTT		     $03,000.00
SMITH		     $00,800.00
ALLEN		     $01,600.00
WARD		     $01,250.00
JONES		     $02,975.00
MARTIN		     $01,250.00
BLAKE		     $02,850.00
CLARK		     $02,450.00
SCOTT		     $03,000.00
KING		     $05,000.00
TURNER		     $01,500.00
ADAMS		     $01,100.00
JAMES		     $00,950.00
FORD		     $03,000.00
MILLER		     $01,300.00

15 rows selected.

    char to_number

TO_NUMBER(char[, 'format_model'])

SQL> select to_number('$00,800.00','L99999.00') from dual;

TO_NUMBER('$00,800.00','L99999.00')
-----------------------------------
				800

SQL> select to_number('$00,800.00','$99999.00') from dual;

TO_NUMBER('$00,800.00','$99999.00')
-----------------------------------
				800

SQL> select to_number('$00,800.00','$9999.00') from dual;
select to_number(' $00,800.00','$9999.00') from dual
                 *
ERROR at line 1:
ORA-01722: invalid number

第二参数指定的数字位数不能小于第一个参数的位数，否则会报错。

    char to_date

TO_DATE(char[, 'format_model'])

SQL> select to_date('1997-10-1','yyyy-mm-dd') from dual;

TO_DATE('
---------
01-OCT-97

SQL> select to_char(to_date('1997-10-1','yyyy-mm-dd'),'yyyy-mm-dd') from dual;

TO_CHAR(TO
----------
1997-10-01

RR和YY年份

yy年份表示法，当前系统时间所在的世纪

    场景重现

1997年10月1日 记录在数据库中用dd-mon-yy表示为 01-OCT-97

    1998年，用户读取该数据，读 yyyy-mm-dd 为 1997-10-01
    2008年，用户读取该数据，读 yyyy-mm-dd 为 2097-10-01

此时就出错了，因为数据库内部使用yy的方式记录年，读取世纪时是根据当前世纪来取的，于是无法跨越千年。

rr年份表示法，以50年为分界，已经取代了yy方式
当前日期 	日期范围 	记录时间 	日期范围 	显示世纪
now 	0-49 	date 	0-49 	本世纪
now 	50-99 	date 	50-99 	本世纪
now 	0-49 	date 	50-99 	上个世纪
now 	50-99 	date 	0-49 	下个世纪

SQL> select
  2  to_char(sysdate,'yyyy') curr_year,
  3  to_char(to_date('07','yy'),'yyyy') yy07,
  4  to_char(to_date('97','yy'),'yyyy') yy97,
  5  to_char(to_date('07','rr'),'yyyy') rr07,
  6  to_char(to_date('97','rr'),'yyyy') rr97
  7  from dual;

CURR YY07 YY97 RR07 RR97
---- ---- ---- ---- ----
2017 2007 2097 2007 1997

-- 将字符串97转换为日期时，一定注意rr和yy，建议不要用两位表示年份。

SQL> select to_char(to_date('97-2-1','rr-mm-dd'),'yyyy-mm-dd') from dual;

TO_CHAR(TO
----------
1997-02-01

SQL> select to_char(to_date('97-2-1','yy-mm-dd'),'yyyy-mm-dd') from dual;

TO_CHAR(TO
----------
2097-02-01

练习以下sql：

select sysdate,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;
select ename,sal,to_char(sal,'L999,999.99') from emp;
select to_number('$800.00','L999.99') from dual;
select to_date('2016-09-15','yyyy-mm-dd') from dual;
select
to_char(sysdate,'yyyy') curr_year,
to_char(to_date('05','yy'),'yyyy') yy05,
to_char(to_date('99','yy'),'yyyy') yy99,
to_char(to_date('05','rr'),'yyyy') rr05,
to_char(to_date('99','rr'),'yyyy') rr99
from dual;

嵌套函数

    单行函数可以嵌套到任意层。
    嵌套函数的计算顺序是从最内层到最外层。

-- 打印出大写的雇员名字从第一位开始的8个字符，并加上'_china'
SQL> select ename,upper(concat(substr(ename,1,8),'_china')) from emp;

ENAME	   UPPER(CONCAT(S
---------- --------------
SCoTT	   SCOTT _CHINA
SMITH	   SMITH_CHINA
ALLEN	   ALLEN_CHINA
WARD	   WARD_CHINA
JONES	   JONES_CHINA
MARTIN	   MARTIN_CHINA
BLAKE	   BLAKE_CHINA
CLARK	   CLARK_CHINA
SCOTT	   SCOTT_CHINA
KING	   KING_CHINA
TURNER	   TURNER_CHINA
ADAMS	   ADAMS_CHINA
JAMES	   JAMES_CHINA
FORD	   FORD_CHINA
MILLER	   MILLER_CHINA

15 rows selected.

-- 打印大写雇员的姓名，去除头尾空白并加上'_china'

SQL> select ename,upper(concat(trim(' ' from ename),'_china')) from emp;

ENAME	   UPPER(CONCAT(TRI
---------- ----------------
SCoTT	   SCOTT_CHINA
SMITH	   SMITH_CHINA
ALLEN	   ALLEN_CHINA
WARD	   WARD_CHINA
JONES	   JONES_CHINA
MARTIN	   MARTIN_CHINA
BLAKE	   BLAKE_CHINA
CLARK	   CLARK_CHINA
SCOTT	   SCOTT_CHINA
KING	   KING_CHINA
TURNER	   TURNER_CHINA
ADAMS	   ADAMS_CHINA
JAMES	   JAMES_CHINA
FORD	   FORD_CHINA
MILLER	   MILLER_CHINA

15 rows selected.
SQL> select to_char(round((sal/7),2),'9G99D99') from emp;

TO_CHAR(
--------
 4,28.57
 1,14.29
 2,28.57
 1,78.57
 4,25.00
 1,78.57
 4,07.14
 3,50.00
 4,28.57
 7,14.29
 2,14.29
 1,57.14
 1,35.71
 4,28.57
 1,85.71

15 rows selected.

SQL> select to_char(round((sal/7),2),'999D99') from emp;

TO_CHAR
-------
 428.57
 114.29
 228.57
 178.57
 425.00
 178.57
 407.14
 350.00
 428.57
 714.29
 214.29
 157.14
 135.71
 428.57
 185.71

15 rows selected.

常规函数

    主要是用来修改空值的；可用于任何数据类型

函数名 	解释
NVL (expr1, expr2) 	1空为2，1不空则1
NVL2 (expr1, expr2, expr3) 	1空为3，1不空为2
NULLIF (expr1, expr2) 	1和2相等则输出null，否则输出1
COALESCE (expr1, expr2, ..., exprn) 	返回枚举中的第一个非空表达式

-- 计算员工工资和奖金的和

SQL> select ename,sal,comm,sal+comm from emp;

ENAME		  SAL	    COMM   SAL+COMM
---------- ---------- ---------- ----------
SCoTT		 3000	      20       3020
SMITH		  800
ALLEN		 1600	     300       1900
WARD		 1250	     500       1750
JONES		 2975
MARTIN		 1250	    1400       2650
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
TURNER		 1500	       0       1500
ADAMS		 1100
JAMES		  950
FORD		 3000
MILLER		 1300

15 rows selected.

SQL> select ename,sal,comm,sal+nvl(comm,0) from emp;

ENAME		  SAL	    COMM SAL+NVL(COMM,0)
---------- ---------- ---------- ---------------
SCoTT		 3000	      20	    3020
SMITH		  800			     800
ALLEN		 1600	     300	    1900
WARD		 1250	     500	    1750
JONES		 2975			    2975
MARTIN		 1250	    1400	    2650
BLAKE		 2850			    2850
CLARK		 2450			    2450
SCOTT		 3000			    3000
KING		 5000			    5000
TURNER		 1500	       0	    1500
ADAMS		 1100			    1100
JAMES		  950			     950
FORD		 3000			    3000
MILLER		 1300			    1300

15 rows selected.

SQL> select nvl2(null,1,2) from dual;

NVL2(NULL,1,2)
--------------
	     2

SQL> select nvl2('a',1,2) from dual;

NVL2('A',1,2)
-------------
	    1

SQL> select nullif(1,1) from dual;

NULLIF(1,1)
-----------


SQL> select nullif(1,2) from dual;

NULLIF(1,2)
-----------
	  1

SQL> select nullif(3,2) from dual;

NULLIF(3,2)
-----------
	  3

-- 有奖金返回奖金，没有奖金返回工资
SQL> select coalesce(comm,sal)from emp;

COALESCE(COMM,SAL)
------------------
		20
	       800
	       300
	       500
	      2975
	      1400
	      2850
	      2450
	      3000
	      5000
		 0
	      1100
	       950
	      3000
	      1300

15 rows selected.

条件表达式

可以在 SQL 语句中使用 IF-THEN-ELSE 逻辑。
条件判断 	语法
CASE表达式 	case exp when 1 then e1 when 2 then e2 end
DECODE函数 	decode(exp,1,e1,2,e2,defaulte3)

-- 职员工资上涨百分之10，销售工资上涨百分之15，其他人不变

SQL> select ename,job,sal,
  2  case job when 'CLERK' then sal*1.1
  3  when 'SALESMAN' then sal*1.15
  4  else sal end rev_sal
  5  from emp;

ENAME	   JOB		    SAL    REV_SAL
---------- --------- ---------- ----------
SCoTT	   ANALYST	   3000       3000
SMITH	   CLERK	    800        880
ALLEN	   SALESMAN	   1600       1840
WARD	   SALESMAN	   1250     1437.5
JONES	   MANAGER	   2975       2975
MARTIN	   SALESMAN	   1250     1437.5
BLAKE	   MANAGER	   2850       2850
CLARK	   MANAGER	   2450       2450
SCOTT	   ANALYST	   3000       3000
KING	   PRESIDENT	   5000       5000
TURNER	   SALESMAN	   1500       1725
ADAMS	   CLERK	   1100       1210
JAMES	   CLERK	    950       1045
FORD	   ANALYST	   3000       3000
MILLER	   CLERK	   1300       1430

15 rows selected.

SQL> select ename,job,sal,decode(sal,'CLERK',sal*1.1,'SALESMAN',sal*1.1,sal) rev_sal from emp;

ENAME	   JOB		    SAL    REV_SAL
---------- --------- ---------- ----------
SCoTT	   ANALYST	   3000       3000
SMITH	   CLERK	    800        800
ALLEN	   SALESMAN	   1600       1600
WARD	   SALESMAN	   1250       1250
JONES	   MANAGER	   2975       2975
MARTIN	   SALESMAN	   1250       1250
BLAKE	   MANAGER	   2850       2850
CLARK	   MANAGER	   2450       2450
SCOTT	   ANALYST	   3000       3000
KING	   PRESIDENT	   5000       5000
TURNER	   SALESMAN	   1500       1500
ADAMS	   CLERK	   1100       1100
JAMES	   CLERK	    950        950
FORD	   ANALYST	   3000       3000
MILLER	   CLERK	   1300       1300

15 rows selected.

-- 工资低于1000并且job为雇员的员工薪资涨百分之15，其他人不涨
-- 非标准的case when，不能转化为decode()
-- 任何条件满足则break

SQL> select ename,job,sal,case when sal>1000 then sal when job='CLERK' then sal*1.15  else sal end as rev_sal from emp;

ENAME	   JOB		    SAL    REV_SAL
---------- --------- ---------- ----------
SCoTT	   ANALYST	   3000       3000
SMITH	   CLERK	    800        920
ALLEN	   SALESMAN	   1600       1600
WARD	   SALESMAN	   1250       1250
JONES	   MANAGER	   2975       2975
MARTIN	   SALESMAN	   1250       1250
BLAKE	   MANAGER	   2850       2850
CLARK	   MANAGER	   2450       2450
SCOTT	   ANALYST	   3000       3000
KING	   PRESIDENT	   5000       5000
TURNER	   SALESMAN	   1500       1500
ADAMS	   CLERK	   1100       1100
JAMES	   CLERK	    950     1092.5
FORD	   ANALYST	   3000       3000
MILLER	   CLERK	   1300       1300

15 rows selected.

练习以下语句

select ename,sal,comm,sal+nvl(comm,0) from emp;
select ename,sal,comm,nvl2(comm,sal+comm,sal) from emp;
select ename,sal,comm,coalesce(comm,sal,0) from emp;

select ename,
       job,
       sal,
case job when 'CLERK' then sal*1.1
         when 'ANALYST' then sal*1.20
else sal end raise_sal
from emp
order by job;

select ename,
       job,
       sal,
decode(job,
      'CLERK',sal*1.1,
      'ANALYST',sal*1.2,
      sal) raise_sal
from emp order by job;

与MySQL的区别
sql 	mysql 	oracle
查看用户的表 	use dbname;show tables; 	conn user/password;select * from tab;
限制行数 	select * from emp limit 5; 	select * from emp where rownum < 6;
MySQL数据库名、表名、列名、别名大小写规则

lower_case_table_names = 0 其中

    0：区分大小写
    1：不区分大小写

MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：

    数据库名与表名是严格区分大小写的；
    表的别名是严格区分大小写的；
    列名与列的别名在所有的情况下均是忽略大小写的；
    变量名也是严格区分大小写的；

root@SH_MySQL-01 17:02:  [(none)]> select @@lower_case_table_names;
+--------------------------+
| @@lower_case_table_names |
+--------------------------+
|                        0 |
+--------------------------+
1 row in set (0.00 sec)

root@SH_MySQL-01 17:03:  [(none)]> use test;
Database changed
root@SH_MySQL-01 17:03:  [test]> select * from T1;
ERROR 1146 (42S02): Table 'test.T1' doesn't exist
root@SH_MySQL-01 17:03:  [test]> select * from t1;
+----+------+
| id | num  |
+----+------+
|  1 |  100 |
|  2 |  200 |
+----+------+
2 rows in set (0.00 sec)

MySQL字符串大小写

校对规则以其相关的字符集名开始，通常包括一个语言名，并且以_ci（大小写不敏感）、_cs（大小写敏感）或_bin（二元）结束 。

比如 utf8字符集，

    utf8_general_ci,表示不区分大小写，这个是utf8字符集默认的校对规则；
    utf8_general_cs表示区分大小写；
    utf8_bin表示二进制比较，同样也区分大小写。

SQL语句-查询语句-多表连接

熟悉每一张表的结构
emp 	解释
EMPNO 	雇员编号
ENAME 	雇员名字
JOB 	职位
MGR 	上级编号
HIREDATE 	雇佣时间
SAL 	工资
COMM 	奖金
DEPTNO 	部门编号

dept 	解释
DEPTNO 	部门编号
DNAME 	部门名称
LOC 	位置

bonus 	解释
ENAME 	雇员名字
JOB 	职位
SAL 	工资
COMM 	奖金

salgrade 	解释
GRADE 	等级
LOSAL 	最低薪资
HISAL 	最高薪资
原理

    N张表相连，需要N-1个条件
    多表连接，在oracle内部是两两相连
    内连接 from a,b where a.id=b.id 
    右连接 from a right join b on a.id=b.id 等效于 from a,b where a.id(+)=b.id
    左连接 from a left join b on a.id=b.id 等小于 from a,b where a.id=b.id(+)
    count(*) 会统计为null的行;count(列名)则不统计null的行
    不等连接 from a,b where a.id between b.cc and b.dd
    自连接 from a t1,b t2 whee t1.id=t2.idd
    笛卡尔连接 from a,b

案例
1. SMITH工作在哪里？

SQL> select ename,loc from emp,dept where emp.deptno=dept.deptno and lower(ename)='smith';

ENAME	   LOC
---------- -------------
SMITH	   DALLAS

2. 10号部门的员工都工作在哪些城市？

SQL> select ename,loc from emp,dept where emp.deptno=dept.deptno and emp.deptno=10;

ENAME	   LOC
---------- -------------
CLARK	   NEW YORK
KING	   NEW YORK
MILLER	   NEW YORK

3. 销售部门都有哪些员工，分别工作在哪些城市？

SQL> select ename,dname,loc from emp,dept where emp.deptno=dept.deptno and lower(dept.dname)='sales';
ENAME	   DNAME	  LOC
---------- -------------- -------------
WARD	   SALES	  CHICAGO
TURNER	   SALES	  CHICAGO
ALLEN	   SALES	  CHICAGO
JAMES	   SALES	  CHICAGO
BLAKE	   SALES	  CHICAGO
MARTIN	   SALES	  CHICAGO

4. 有所的员工姓名和对应的工作城市

SQL> select ename,loc from emp,dept where emp.deptno=dept.deptno;

ENAME	   LOC
---------- -------------
CLARK	   NEW YORK
KING	   NEW YORK
MILLER	   NEW YORK
JONES	   DALLAS
FORD	   DALLAS
ADAMS	   DALLAS
SMITH	   DALLAS
SCOTT	   DALLAS
WARD	   CHICAGO
TURNER	   CHICAGO
ALLEN	   CHICAGO
JAMES	   CHICAGO
BLAKE	   CHICAGO
MARTIN	   CHICAGO

5. 每个城市和对应的员工姓名，虽然波士顿没有员工，但是公司是有波士顿分部的，波士顿也要统计出来。

SQL> select ename,loc from emp,dept where emp.deptno(+)=dept.deptno;

ENAME	   LOC
---------- -------------
CLARK	   NEW YORK
KING	   NEW YORK
MILLER	   NEW YORK
JONES	   DALLAS
FORD	   DALLAS
ADAMS	   DALLAS
SMITH	   DALLAS
SCOTT	   DALLAS
WARD	   CHICAGO
TURNER	   CHICAGO
ALLEN	   CHICAGO
JAMES	   CHICAGO
BLAKE	   CHICAGO
MARTIN	   CHICAGO
	   BOSTON

15 rows selected.

SQL> select ename,loc from emp right join dept on emp.deptno=dept.deptno;

ENAME	   LOC
---------- -------------
CLARK	   NEW YORK
KING	   NEW YORK
MILLER	   NEW YORK
JONES	   DALLAS
FORD	   DALLAS
ADAMS	   DALLAS
SMITH	   DALLAS
SCOTT	   DALLAS
WARD	   CHICAGO
TURNER	   CHICAGO
ALLEN	   CHICAGO
JAMES	   CHICAGO
BLAKE	   CHICAGO
MARTIN	   CHICAGO
	   BOSTON

15 rows selected.

6. 每个城市工作的员工有几个？

SQL> select loc,count(*) from emp,dept where emp.deptno=dept.deptno group by loc;

LOC		COUNT(*)
------------- ----------
NEW YORK	       3
CHICAGO 	       6
DALLAS		       5

    以上结果不够准确，因为波士顿还有分部，要加上波士顿

SQL> select count(ename),loc from emp right join dept on emp.deptno=dept.deptno group by loc;

COUNT(ENAME) LOC
------------ -------------
	   3 NEW YORK
	   6 CHICAGO
	   0 BOSTON
	   5 DALLAS

SQL> select count(*),loc from emp right join dept on emp.deptno=dept.deptno group by loc;

  COUNT(*) LOC
---------- -------------
	 3 NEW YORK
	 6 CHICAGO
	 1 BOSTON
	 5 DALLAS

以上统计中，必须使用count(列名)，count(*)将null值也统计进去了。
7. 每一个员工的工资等级是多少

SQL> select ename,grade from emp,salgrade where sal > losal and sal < hisal;

ENAME		GRADE
---------- ----------
SMITH		    1
JAMES		    1
ADAMS		    1
WARD		    2
MARTIN		    2
MILLER		    2
TURNER		    3
ALLEN		    3
CLARK		    4
BLAKE		    4
JONES		    4
KING		    5

12 rows selected.

SQL> select ename,grade from emp,salgrade where sal between losal and  hisal;

ENAME		GRADE
---------- ----------
SMITH		    1
JAMES		    1
ADAMS		    1
WARD		    2
MARTIN		    2
MILLER		    2
TURNER		    3
ALLEN		    3
CLARK		    4
BLAKE		    4
JONES		    4
SCOTT		    4
FORD		    4
KING		    5

14 rows selected.

oralce 不等连接
8. 每一个员工的直属领导者是谁？

SQL> select a.ename ename,b.ename manager from emp a,emp  b where a.mgr=b.empno;

ENAME	   MANAGER
---------- ----------
FORD	   JONES
SCOTT	   JONES
TURNER	   BLAKE
ALLEN	   BLAKE
WARD	   BLAKE
JAMES	   BLAKE
MARTIN	   BLAKE
MILLER	   CLARK
ADAMS	   SCOTT
BLAKE	   KING
JONES	   KING
CLARK	   KING
SMITH	   FORD

13 rows selected.

自连接
国标连接语法
国标 	语法 	oracle 	语法 	备注
交叉连接 	select ename,loc from emp cross join dept; 	笛卡尔连接 	select ename,loc from emp,dept; 	
自然连接-有同名列 	select ename,loc from emp natural join dept; 	等值连接 	select ename,loc from emp,dept where emp.deptno=dept.deptno 	自然连接的前提条件是必须拥有同名的列
自然连接-多个同名列 	select ename,loc from emp join dept using (col1); 	等值连接 	select ename,loc from emp,dept where emp.deptno=dept.deptno 	;若两张表有多个同名列则需要用using(col)修正；
自然连接-无同名列 	select ename,loc from emp join dept on (emp.col1=dept.col2); 	等值连接 	select ename,loc from emp,dept where emp.col1=dept.col2 	若两张表没有同名的列则用on(a.co1=b.co2);
右外连接 	select ename,loc from emp right outer join dept using (deptno); 	右连接 	select ename,loc from emp,dept where emp.deptno(+)=dept.deptno; 	以右表为准
左外连接 	select ename,loc from emp left outer join dept using (deptno); 	左连接 	select ename,loc from emp,dept where emp.deptno=dept.deptno(+); 	以左表为准
全外连接 	select ename,loc from emp full outer join dept using (deptno); 	比较复杂 		

推荐使用国标，功能全，oracle书写简单


SQL语句-查询语句-组函数

组函数语法

    对多行进行的计算

组函数类型 	解释
avg() 	平均
count() 	统计
max() 	最大值
min() 	最小值
stddev 	估算标准偏差
sum 	求和
variance 	方差

    group by 字句进行分组
    having 字句聚合函数过滤

序列 	举例
row_number() over (partition by col1 order by col2)表示根据col1分组，在分组内部根据col2排序，而此函数计算的值就表示每组内部排序后的顺序编号（组内连续的唯一的）。 
rank() over (partition by col1 order by col2)
dense_rank() over (partition by col1 order by col2)

rank()是跳跃排序，有两个第二名时接下来就是第四名（同样是在各个分组内）
dense_rank()是连续排序，有两个第二名时仍然跟着第三名。

select rank() over (partition by deptno order by sal desc) ord from emp;

    partition by 给结果集分组
    order by 给结果集排序
    rank() 在每个分组内部进行排名

应用实例
1. 雇员中最大工资，最小工资，工资总和，平均工资。

SQL> select min(sal),max(sal),sum(sal),avg(sal) from emp;

  MIN(SAL)   MAX(SAL)	SUM(SAL)   AVG(SAL)
---------- ---------- ---------- ----------
       800	 5000	   29025 2073.21429

2. 每个部门的工资总和和平均值

SQL> select deptno,to_char(avg(sal),'L99999.99') avg_sal,to_char(sum(sal),'L99999.99') sum_sal from emp group by deptno;

    DEPTNO AVG_SAL	       SUM_SAL
---------- ------------------- -------------------
	30	      $1566.67		  $9400.00
	20	      $2175.00		 $10875.00
	10	      $2916.67		  $8750.00

3. 部门工资总和的最大值为多少

SQL> select max(sum(sal)) from emp group by deptno;

MAX(SUM(SAL))
-------------
	10875

4. 部门工资总和最多的部门名称和工资总和

SQL> select deptno,sum_sal from (select deptno,sum(sal) sum_sal from emp group by deptno order by sum_sal desc ) where rownum < 2;

    DEPTNO    SUM_SAL
---------- ----------
	20	10875

5. 工资总和超过9000的部门

SQL> select deptno,sum(sal) sum_sal from emp group by deptno having sum_sal > 9000;
select deptno,sum(sal) sum_sal from emp group by deptno having sum_sal > 9000
                                                               *
ERROR at line 1:
ORA-00904: "SUM_SAL": invalid identifier


SQL> select deptno,sum(sal) sum_sal from emp group by deptno having sum(sal) > 9000;

    DEPTNO    SUM_SAL
---------- ----------
	30	 9400
	20	10875

    注意having字句后面不可以使用别名。
    where字句不可以过滤组函数运算后的结果。

6. 雇员中工资相同的员工分别是谁，工资为所少？

SQL> select e1.ename,e2.ename,e1.sal from emp e1,emp e2 where e1.sal=e2.sal and e1.ename != e2.ename;

ENAME	   ENAME	     SAL
---------- ---------- ----------
MARTIN	   WARD 	    1250
WARD	   MARTIN	    1250
FORD	   SCOTT	    3000
SCOTT	   FORD 	    3000

7. 相同的工资有几个？

SQL> select sal,count(sal) from emp group by sal;

       SAL COUNT(SAL)
---------- ----------
      2450	    1
      5000	    1
      1300	    1
      1250	    2
      2850	    1
      2975	    1
      1100	    1
      3000	    2
       800	    1
      1600	    1
      1500	    1

       SAL COUNT(SAL)
---------- ----------
       950	    1

12 rows selected.

SQL> select sal,count(sal) from emp group by sal having count(sal)>1;

       SAL COUNT(SAL)
---------- ----------
      1250	    2
      3000	    2

SQL> select sal from emp group by sal having count(sal)>1;

       SAL
----------
      1250
      3000

SQL> select ename,sal from emp where sal in (select sal from emp group by sal having count(sal)>1);

ENAME		  SAL
---------- ----------
WARD		 1250
MARTIN		 1250
SCOTT		 3000
FORD		 3000

8. 每一年参加工作的雇员的数量

SQL> select count(to_char(hiredate,'yyyy')) enum, to_char(hiredate,'yyyy') year from emp group by to_char(hiredate,'yyyy');

      ENUM YEAR
---------- ----
	 2 1987
	 1 1980
	 1 1982
	10 1981

SQL> select sum(case when to_char(hiredate,'yy')='81' then 1 else 0 end) "81",sum(decode(to_char(hiredate,'yy'),82,1,0)) "82",sum(decode(to_char(hiredate,'yy'),80,1,0)) "80",sum(decode(to_char(hiredate,'yy'),87,1,0)) "87" from emp;

	81	   82	      80	 87
---------- ---------- ---------- ----------
	10	    1	       1	  2

课后练习

select max(sal),min(sal),sum(sal),avg(sal) from emp;

select count(*) from emp;
select count(*) from emp where deptno=30;
select count(deptno) from emp;
select count(distinct deptno) from emp;
select count(comm) from emp;
select avg(comm) from emp;
select avg(nvl(comm,0)) from emp;
select deptno,sum(sal) from emp group by deptno;
select deptno,job,sum(sal) from emp group by deptno,job;
select deptno,sum(sal) from emp having sum(sal)>9000 group by deptno;
--------------------------------
10部门的最大工资
--------------------------------
查找重复的工资
--------------------------------
80年 81年 82年 87年都有多少新员工

1980  1981  1982  1987
----  ----  ----  ----
   1    10     1     2
--------------------------------


SQL语句-查询语句-子查询和SQLPlus

子查询类型、语法和准则

select ename,sal,deptno from emp order by dbms_random.value();
* order by 排序
* dbms_random.value() 随机数

select * from (select rownum rn,a.* from (select * from emp order by sal desc) a) where rn between &p*5-4 and &p*5;

    &p 为自定义变量

    where 型
        单行 = 、 != 、 > 、 < 、 <= 、 >=等
        多行 in、any、all

    from 型

    exits 型

子查询3种{

	where 型{

		# 把内层查询的结果作为外层查询的比较条件
		# 查询最大、最贵商品

		查询最新的商品（以id最大为最新，不用order by）:{
			select goods_id,goods_name from goods where goods_id = (select max(goods_id) from goods);
		}
		每个栏目下最新的商品：{
			select cat_id,goods_id,goods_name from goods where goods_id in (select max(goods_id) from goods group by cat_id);
		}
		每个栏目下最贵的商品：{
			select cat_id,goods_id,goods_name,shop_price from goods where shop_price in (select max(shop_price) from goods group by cat_id);
		}

	}

	from 型{

		# 把内层查询的结果作为外层查询的临时表
		# 查询每个栏目下最新、最贵商品

		每个栏目下最新的商品：{
			select * from (select cat_id,goods_id,goods_name from goods order by cat_id,goods_id desc) as a group by cat_id;
		}

	}

	exits 型{

		# 把外层的查询结果，拿到内层，看内存查询是否成立
		# 查询有商品的栏目

		查有商品的栏目{
			select cat_id,cat_name from category where cat_id in (select cat_id from goods where cat_id in (select cat_id from category) group by cat_id);
			select cat_id,cat_name from category where exists (select * from goods where goods.cat_id = category.cat_id);
		}
	}

子查询练习
1. 工资高于BLAKE的？

SQL> select ename,sal from emp where sal > (select sal from emp where ename='BLAKE');

ENAME		  SAL
---------- ----------
JONES		 2975
SCOTT		 3000
KING		 5000
FORD		 3000

2. 工资最低的人？

SQL> select ename,sal from emp where sal = (select min(sal) from emp);

ENAME		  SAL
---------- ----------
SMITH		  800

3. 低于10部门最低工资的人？

SQL> select ename,sal from emp where sal < all (select sal from emp where deptno=10);

ENAME		  SAL
---------- ----------
WARD		 1250
MARTIN		 1250
ADAMS		 1100
JAMES		  950
SMITH		  800

SQL> select ename,sal from emp where sal < (select min(sal) from emp where deptno=10);

ENAME		  SAL
---------- ----------
SMITH		  800
WARD		 1250
MARTIN		 1250
ADAMS		 1100
JAMES		  950

4. 高于30部门最高工资的人？

SQL> select ename,sal from emp where sal > all (select sal from emp where deptno=30);

ENAME		  SAL
---------- ----------
JONES		 2975
SCOTT		 3000
FORD		 3000
KING		 5000

SQL> select ename,sal from emp where sal > (select max(sal) from emp where deptno=30);

ENAME		  SAL
---------- ----------
JONES		 2975
SCOTT		 3000
KING		 5000
FORD		 3000

5. 工资相同的人？

SQL> select a.ename,b.ename,a.sal from emp a ,emp b where a.sal=b.sal and a.ename!=b.ename;

ENAME	   ENAME	     SAL
---------- ---------- ----------
MARTIN	   WARD 	    1250
WARD	   MARTIN	    1250
FORD	   SCOTT	    3000
SCOTT	   FORD 	    3000

6. blake的工资是smith的几倍？

SQL> select (select sal from emp where ename='BLAKE')/(select sal from emp where ename='SMITH') "B-S" from dual;

       B-S
----------
    3.5625

7. 每个部门工资最高的人？

SQL> select deptno,ename,sal from emp where sal in (select max(sal) from emp group by deptno) order by deptno ;

    DEPTNO ENAME	     SAL
---------- ---------- ----------
	10 KING 	    5000
	20 FORD 	    3000
	20 SCOTT	    3000
	30 BLAKE	    2850

SQL> select ename,deptno,sal,rank () over (partition by deptno order by sal desc) Ord from emp;

ENAME	       DEPTNO	     SAL	ORD
---------- ---------- ---------- ----------
KING		   10	    5000	  1
CLARK		   10	    2450	  2
MILLER		   10	    1300	  3
SCOTT		   20	    3000	  1
FORD		   20	    3000	  1
JONES		   20	    2975	  3
ADAMS		   20	    1100	  4
SMITH		   20	     800	  5
BLAKE		   30	    2850	  1
ALLEN		   30	    1600	  2
TURNER		   30	    1500	  3

ENAME	       DEPTNO	     SAL	ORD
---------- ---------- ---------- ----------
MARTIN		   30	    1250	  4
WARD		   30	    1250	  4
JAMES		   30	     950	  6

14 rows selected.

SQL> select * from (select ename,deptno,sal,rank () over (partition by deptno order by sal desc) Ord from emp) where ord<=1;

ENAME	       DEPTNO	     SAL	ORD
---------- ---------- ---------- ----------
KING		   10	    5000	  1
SCOTT		   20	    3000	  1
FORD		   20	    3000	  1
BLAKE		   30	    2850	  1

8. 每个部门工资最高的前2个人？

SQL> select * from (select ename,deptno,sal,rank () over (partition by deptno order by sal desc) Ord from emp) where ord<=2;

ENAME	       DEPTNO	     SAL	ORD
---------- ---------- ---------- ----------
KING		   10	    5000	  1
CLARK		   10	    2450	  2
SCOTT		   20	    3000	  1
FORD		   20	    3000	  1
BLAKE		   30	    2850	  1
ALLEN		   30	    1600	  2

6 rows selected.

9. 工资最高的前5行？

SQL> select * from (select ename,deptno,sal,rank () over (order by sal desc) ord from emp) where ord <=5 ;

ENAME	       DEPTNO	     SAL	ORD
---------- ---------- ---------- ----------
KING		   10	    5000	  1
SCOTT		   20	    3000	  2
FORD		   20	    3000	  2
JONES		   20	    2975	  4
BLAKE		   30	    2850	  5

SQL> select * from (select ename,deptno,sal from emp order by sal desc) where rownum < 6;

ENAME	       DEPTNO	     SAL
---------- ---------- ----------
KING		   10	    5000
SCOTT		   20	    3000
FORD		   20	    3000
JONES		   20	    2975
BLAKE		   30	    2850

10. 工资6～10名？

SQL> select * from (select ename,deptno,sal,rank () over (order by sal desc) ord from emp) where ord between 6 and 10 ;

ENAME	       DEPTNO	     SAL	ORD
---------- ---------- ---------- ----------
CLARK		   10	    2450	  6
ALLEN		   30	    1600	  7
TURNER		   30	    1500	  8
MILLER		   10	    1300	  9
WARD		   30	    1250	 10
MARTIN		   30	    1250	 10

6 rows selected.

11. 随机从表中取出3行数据？

SQL> select ename,sal,deptno from emp order by dbms_random.value();

ENAME		  SAL	  DEPTNO
---------- ---------- ----------
SMITH		  800	      20
FORD		 3000	      20
BLAKE		 2850	      30
CLARK		 2450	      10
TURNER		 1500	      30
ALLEN		 1600	      30
MILLER		 1300	      10
JONES		 2975	      20
MARTIN		 1250	      30
KING		 5000	      10
SCOTT		 3000	      20

ENAME		  SAL	  DEPTNO
---------- ---------- ----------
ADAMS		 1100	      20
WARD		 1250	      30
JAMES		  950	      30

14 rows selected.

SQL> select * from (select ename,sal,deptno from emp order by dbms_random.value()) where rownum <= 3;

ENAME		  SAL	  DEPTNO
---------- ---------- ----------
WARD		 1250	      30
MARTIN		 1250	      30
TURNER		 1500	      30

SQL> select * from (select ename,sal,deptno from emp order by dbms_random.value()) where rownum <= 3;

ENAME		  SAL	  DEPTNO
---------- ---------- ----------
SCOTT		 3000	      20
MILLER		 1300	      10
WARD		 1250	      30

12. 查询雇员的姓名，工资，税，(1级不缴税，2-->2% ,3-->3%,4-->4%,5-->5%)

SQL> select ename,sal,grade,decode(grade,1,0,2,sal*0.02,3,sal*0.03,4,sal*0.04,5,sal*0.05) T from emp,salgrade where emp.sal between salgrade.losal and salgrade.hisal;

ENAME		  SAL	   GRADE	  T
---------- ---------- ---------- ----------
SMITH		  800	       1	  0
JAMES		  950	       1	  0
ADAMS		 1100	       1	  0
WARD		 1250	       2	 25
MARTIN		 1250	       2	 25
MILLER		 1300	       2	 26
TURNER		 1500	       3	 45
ALLEN		 1600	       3	 48
CLARK		 2450	       4	 98
BLAKE		 2850	       4	114
JONES		 2975	       4	119

ENAME		  SAL	   GRADE	  T
---------- ---------- ---------- ----------
SCOTT		 3000	       4	120
FORD		 3000	       4	120
KING		 5000	       5	250

14 rows selected.

13. 部门总工资和部门上缴个税总和

SQL> select deptno,sum(sal),sum(T) from (select deptno,ename,sal,grade,decode(grade,1,0,2,sal*0.02,3,sal*0.03,4,sal*0.04,5,sal*0.05) T from emp,salgrade where emp.sal between salgrade.losal and salgrade.hisal) group by deptno;

    DEPTNO   SUM(SAL)	  SUM(T)
---------- ---------- ----------
	30	 9400	     257
	20	10875	     359
	10	 8750	     374

14. 比WARD奖金低的人？

SQL> select ename,comm from emp where nvl(comm,0) < (select comm from emp where ename='WARD');

ENAME		 COMM
---------- ----------
SMITH
ALLEN		  300
JONES
BLAKE
CLARK
SCOTT
KING
TURNER		    0
ADAMS
JAMES
FORD

ENAME		 COMM
---------- ----------
MILLER

12 rows selected.

15. 奖金最高的前两名雇员？

SQL> select * from (select ename,comm from emp order by nvl(comm,0) desc) where rownum <= 2;

ENAME		 COMM
---------- ----------
MARTIN		 1400
WARD		  500


SQL> select * from (select ename,nvl(comm,0),rank () over (order by nvl(comm,0) desc) ord from emp) where ord <= 2;

ENAME	   NVL(COMM,0)	      ORD
---------- ----------- ----------
MARTIN		  1400		1
WARD		   500		2

16. 工资高于本部门平均工资的人？

SQL> select e.deptno,e.ename,e.sal from emp e,(select deptno,avg(sal) asal from emp group by deptno) b where e.deptno=b.deptno and e.sal > b.asal;

    DEPTNO ENAME	     SAL
---------- ---------- ----------
	30 BLAKE	    2850
	30 ALLEN	    1600
	20 FORD 	    3000
	20 SCOTT	    3000
	20 JONES	    2975
	10 KING 	    5000

6 rows selected.

课后练习

select deptno,ename, sal
from emp
where sal in (select max(sal) from emp group by deptno) or
sal in (select max(sal)
       from (select sal,deptno
             from emp where sal not in
                      (select max(sal) from emp group by deptno)) group by deptno)
order by 1;

select ename,deptno,sal from emp e where (select count(*) from emp where sal>e.sal and deptno=e.deptno)<2;

select count(*) from emp where sal>800 and deptno=20;

select * from (select ename,deptno,sal,rank () over (partition by deptno order by sal desc) Ord from emp) where ord<=2;

select ename,deptno,sal,row_number () over (partition by deptno order by sal desc) Ord from emp;

select * from (select rownum rn,a.* from (select ename,sal from emp order by sal desc) a) where rn between 6 and 10;

select * from (select * from emp order by dbms_random.value()) where rownum<=3;

查询雇员的姓名，工资，税，(1级不缴税，2-->2% ,3-->3%,4-->4%,5-->5%)
select
  e.ename,
  e.sal,
  (sal*decode(s.grade,1,0,2,0.02,3,0.03,4,0.04,5,0.05,0)) tax
from emp e,salgrade s
where e.sal between s.losal and s.hisal;

部门总工资和部门上缴个税总和
select deptno,sum(sal),sum(tax)
from
(select
  e.sal,
  (sal*decode(s.grade,1,0,2,0.02,3,0.03,4,0.04,5,0.05,0)) tax,
  deptno
from emp e,salgrade s
where e.sal between s.losal and s.hisal)
group by deptno;

比WARD奖金低的人？
select ename,comm from emp where NVL(comm,0)<(select comm from emp where ename='WARD');

select ename,comm from emp where comm<(select comm from emp where ename='WARD') or comm is null;

奖金最高的前两名雇员？
select * from (select ename,comm from emp order by comm desc nulls last) where rownum<=2;

select * from (select ename,comm from emp where comm is not null order by comm desc) where rownum<=2;

工资高于本部门平均工资的人？
select e.deptno,e.ename,e.sal from emp e,(select deptno,avg(sal) asal from emp group by deptno) b where e.deptno=b.deptno and e.sal > b.asal;


使用替代变量进行分页查询
select * from (select rownum rn,a.* from (select * from emp order by sal desc) a)
where rn between &p*5-4 and &p*5;

SQLPlus 的常用命令
pause命令暂停屏幕输出

    查看当前pause的状态为off

SQL> show pause;
PAUSE is OFF

    将pasue设置为开启状态 on

SQL> set pause on;
SQL> show pause;
PAUSE is ON and set to ""

    查看当前设置的pagesize的大小，即每页显示多少行

SQL> show pagesize;
pagesize 14

    修改pagesize为10，每页显示10行

SQL> set pagesize 10;

    执行查询语句

SQL> select rownum rn,ename,sal from emp;

需要输入enter健

	RN ENAME	     SAL
---------- ---------- ----------
	 1 SMITH	     800
	 2 ALLEN	    1600
	 3 WARD 	    1250
	 4 JONES	    2975
	 5 MARTIN	    1250
	 6 BLAKE	    2850
	 7 CLARK	    2450

需要输入enter健

	RN ENAME	     SAL
---------- ---------- ----------
	 8 SCOTT	    3000
	 9 KING 	    5000
	10 TURNER	    1500
	11 ADAMS	    1100
	12 JAMES	     950
	13 FORD 	    3000
	14 MILLER	    1300

14 rows selected.

通过sqlplus执行shell命令

    host 或者 ！

执行shell命令 pwd 打印当前路径

SQL> host pwd
/home/oracle

执行shell命令 free 查看当前内存使用情况

SQL> host free
             total       used       free     shared    buffers     cached
Mem:       2058756     937308    1121448          0      49720     683304
-/+ buffers/cache:     204284    1854472
Swap:      4095992          0    4095992

spool保存执行记录

    在当前目录下创建booboo.lst文件保存sql

SQL> spool booboo append

    执行sql查询

SQL> select * from (select ename,nvl(comm,0),rank () over (order by nvl(comm,0) desc) ord from emp) where ord <= 2;

ENAME      NVL(COMM,0)        ORD                                               
---------- ----------- ----------
MARTIN            1400          1                                               
WARD               500          2

    执行sql查询

SQL> select deptno,sum(sal),sum(T) from (select deptno,ename,sal,grade,decode(grade,1,0,2,sal*0.02,3,sal*0.03,4,sal*0.04,5,sal*0.05) T from emp,salgrade where emp.sal between salgrade.losal and salgrade.hisal) group by deptno;

    DEPTNO   SUM(SAL)     SUM(T)                                                
---------- ---------- ----------
        30       9400        257                                                
        20      10875        359                                                
        10       8750        374   

    关闭spool

SQL> spool off

    查看保存的执行记录

[oracle@oracle0 ~]$ cat booboo.lst
SQL> select * from (select ename,nvl(comm,0),rank () over (order by nvl(comm,0) desc) ord from emp) where ord <= 2;

ENAME      NVL(COMM,0)        ORD                                               
---------- ----------- ----------
MARTIN            1400          1                                               
WARD               500          2                                               

SQL> select deptno,sum(sal),sum(T) from (select deptno,ename,sal,grade,decode(grade,1,0,2,sal*0.02,3,sal*0.03,4,sal*0.04,5,sal*0.05) T from emp,salgrade where emp.sal between salgrade.losal and salgrade.hisal) group by deptno;

    DEPTNO   SUM(SAL)     SUM(T)                                                
---------- ---------- ----------
        30       9400        257                                                
        20      10875        359                                                
        10       8750        374                                                

SQL> spool off

SQL语句-查询语句-SQLPlus和变量

变量的类型
变量类型 	设置 	查看 	调用 	备注
替代变量 	define p=sal 	define p 	&p 或者 &&p 	临时生效，可以出现在任何位置
SQLPlus环境变量 	set echo on 	show echo 		当前会话生效
SQLPlus环境变量 	配置文件 	show echo 		永久生效
替代变量

若没有事先声明一个变量，那么引用的时候：

    &p 代表一次性声明，从键盘输入变量的值，下次还需要再次输入，define命令不能看到p变量
    &&p 代表当前会话中的声明，从键盘输入变量的值，下次就不需要再输入，define命令能看到p变量

实践1-where 字句中包含替代变量

查询emp表中部门编号为变量p的值的员工姓名

SQL> select ename,deptno from emp where deptno=&p;
Enter value for p: 10
old   1: select ename,deptno from emp where deptno=&p
new   1: select ename,deptno from emp where deptno=10

ENAME	       DEPTNO
---------- ----------
CLARK		   10
KING		   10
MILLER		   10

SQL> select ename,deptno from emp where deptno=&p;
Enter value for p: 20
old   1: select ename,deptno from emp where deptno=&p
new   1: select ename,deptno from emp where deptno=20

ENAME	       DEPTNO
---------- ----------
SMITH		   20
JONES		   20
SCOTT		   20
ADAMS		   20
FORD		   20

实践2-select 字句中包含替代变量

查看雇员姓名和变量c的值

SQL> select ename,&c from emp;
Enter value for c: deptno
old   1: select ename,&c from emp
new   1: select ename,deptno from emp

ENAME	       DEPTNO
---------- ----------
SMITH		   20
ALLEN		   30
WARD		   30
JONES		   20
MARTIN		   30
BLAKE		   30
CLARK		   10
SCOTT		   20
KING		   10
TURNER		   30
ADAMS		   20

ENAME	       DEPTNO
---------- ----------
JAMES		   30
FORD		   20
MILLER		   10

14 rows selected.

SQL> select ename,&c from emp;
Enter value for c: sal
old   1: select ename,&c from emp
new   1: select ename,sal from emp

ENAME		  SAL
---------- ----------
SMITH		  800
ALLEN		 1600
WARD		 1250
JONES		 2975
MARTIN		 1250
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
TURNER		 1500
ADAMS		 1100

ENAME		  SAL
---------- ----------
JAMES		  950
FORD		 3000
MILLER		 1300

14 rows selected.

实践3-from 字句中包含替代变量

查看变量p所代表的表中的前5行

SQL> select * from &t where rownum < 6;
Enter value for t: salgrade
old   1: select * from &t where rownum < 6
new   1: select * from salgrade where rownum < 6

     GRADE	LOSAL	   HISAL
---------- ---------- ----------
	 1	  700	    1200
	 2	 1201	    1400
	 3	 1401	    2000
	 4	 2001	    3000
	 5	 3001	    9999

SQL> select * from &t where rownum < 6;
Enter value for t: dept
old   1: select * from &t where rownum < 6
new   1: select * from dept where rownum < 6

    DEPTNO DNAME	  LOC
---------- -------------- -------------
	10 ACCOUNTING	  NEW YORK
	20 RESEARCH	  DALLAS
	30 SALES	  CHICAGO
	40 OPERATIONS	  BOSTON

实践4-如果替代变量的类型为字符串，需要加单引号

查询emp表中雇员姓名为某个值的

SQL> select * from emp where ename=&e;
Enter value for e: scott
old   1: select * from emp where ename=&e
new   1: select * from emp where ename=scott
select * from emp where ename=SCOTT
                              *
ERROR at line 1:
ORA-00904: "SCOTT": invalid identifier


SQL> select * from emp where ename='&e';
Enter value for e: SCOTT
old   1: select * from emp where ename='&e'
new   1: select * from emp where ename='SCOTT'

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM
---------- ---------- --------- ---------- --------- ---------- ----------
    DEPTNO
----------
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3000
	20

实践5-分页查询:每页5行

按照工资高低排序，并分页显示，每页5行

1 1 5
2 6 10
3 11 15
n n*5-4   n*5

SQL> select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &p*5-4 and &p*5;
Enter value for p: 1
Enter value for p: 1
old   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &p*5-4 and &p*5
new   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between 1*5-4 and 1*5

	RN ENAME	     SAL
---------- ---------- ----------
	 1 KING 	    5000
	 2 FORD 	    3000
	 3 SCOTT	    3000
	 4 JONES	    2975
	 5 BLAKE	    2850

SQL> /
Enter value for p: 2
Enter value for p: 2
old   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &p*5-4 and &p*5
new   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between 2*5-4 and 2*5

	RN ENAME	     SAL
---------- ---------- ----------
	 6 CLARK	    2450
	 7 ALLEN	    1600
	 8 TURNER	    1500
	 9 MILLER	    1300
	10 WARD 	    1250

SQL> /
Enter value for p: 3
Enter value for p: 3
old   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &p*5-4 and &p*5
new   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between 3*5-4 and 3*5

	RN ENAME	     SAL
---------- ---------- ----------
	11 MARTIN	    1250
	12 ADAMS	    1100
	13 JAMES	     950
	14 SMITH	     800

实践6-替代变量的声明调用查看取消

SQL> define
DEFINE _DATE	       = "31-JUL-17" (CHAR)
DEFINE _CONNECT_IDENTIFIER = "orcl" (CHAR)
DEFINE _USER	       = "SCOTT" (CHAR)
DEFINE _PRIVILEGE      = "" (CHAR)
DEFINE _SQLPLUS_RELEASE = "1102000400" (CHAR)
DEFINE _EDITOR	       = "vim" (CHAR)
DEFINE _O_VERSION      = "Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options" (CHAR)
DEFINE _O_RELEASE      = "1102000400" (CHAR)

声明一个替代变量define

SQL> define col=sal

SQL> define
DEFINE _DATE	       = "31-JUL-17" (CHAR)
DEFINE _CONNECT_IDENTIFIER = "orcl" (CHAR)
DEFINE _USER	       = "SCOTT" (CHAR)
DEFINE _PRIVILEGE      = "" (CHAR)
DEFINE _SQLPLUS_RELEASE = "1102000400" (CHAR)
DEFINE _EDITOR	       = "vim" (CHAR)
DEFINE _O_VERSION      = "Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options" (CHAR)
DEFINE _O_RELEASE      = "1102000400" (CHAR)
DEFINE COL	       = "sal" (CHAR)

SQL> select ename,&col from emp;
old   1: select ename,&col from emp
new   1: select ename,sal from emp

ENAME		  SAL
---------- ----------
SMITH		  800
ALLEN		 1600
WARD		 1250
JONES		 2975
MARTIN		 1250
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
TURNER		 1500
ADAMS		 1100

ENAME		  SAL
---------- ----------
JAMES		  950
FORD		 3000
MILLER		 1300

14 rows selected.

查看变量的值

SQL> select '&col' from dual;
old   1: select '&col' from dual
new   1: select 'sal' from dual

SA
---
sal

取消变量undefine

SQL> undefine col
SQL> define
DEFINE _DATE	       = "31-JUL-17" (CHAR)
DEFINE _CONNECT_IDENTIFIER = "orcl" (CHAR)
DEFINE _USER	       = "SCOTT" (CHAR)
DEFINE _PRIVILEGE      = "" (CHAR)
DEFINE _SQLPLUS_RELEASE = "1102000400" (CHAR)
DEFINE _EDITOR	       = "vim" (CHAR)
DEFINE _O_VERSION      = "Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options" (CHAR)
DEFINE _O_RELEASE      = "1102000400" (CHAR)
SQL> select '&col' from dual;
Enter value for col: xx
old   1: select '&col' from dual
new   1: select 'xx' from dual

'X'
--
xx

实践7-&&的作用

SQL> select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &&p*5-4 and &p*5;
Enter value for p: 1
old   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &&p*5-4 and &p*5
new   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between 1*5-4 and 1*5

	RN ENAME	     SAL
---------- ---------- ----------
	 1 KING 	    5000
	 2 FORD 	    3000
	 3 SCOTT	    3000
	 4 JONES	    2975
	 5 BLAKE	    2850

SQL> definle
SP2-0042: unknown command "definle" - rest of line ignored.
SQL> define
DEFINE _DATE	       = "31-JUL-17" (CHAR)
DEFINE _CONNECT_IDENTIFIER = "orcl" (CHAR)
DEFINE _USER	       = "SCOTT" (CHAR)
DEFINE _PRIVILEGE      = "" (CHAR)
DEFINE _SQLPLUS_RELEASE = "1102000400" (CHAR)
DEFINE _EDITOR	       = "vim" (CHAR)
DEFINE _O_VERSION      = "Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options" (CHAR)
DEFINE _O_RELEASE      = "1102000400" (CHAR)
DEFINE P	       = "1" (CHAR)

SQL> select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &&p*5-4 and &p*5;
old   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between &&p*5-4 and &p*5
new   1: select b.* from (select rownum rn,a.* from (select ename,sal from emp order by sal desc ) a ) b where rn between 1*5-4 and 1*5

	RN ENAME	     SAL
---------- ---------- ----------
	 1 KING 	    5000
	 2 FORD 	    3000
	 3 SCOTT	    3000
	 4 JONES	    2975
	 5 BLAKE	    2850

    优点是第二个&p不需要手动输入了
    缺点在于下一次如果需要修改p的值，还得undefine

SQLPlus环境变量
SET 变量和值 	描述 	备注
VERIFY {OFF|ON} 	新老两行的比较是否显示 	默认开启
ECHO {OFF|ON} 	执行sql脚本时，是否显示脚本中的sql语句 	默认关闭
ARRAY[SIZE] {20| n} 	设置数据库取回数据的大小（行） 	默认为15，范围为1～5000
FEED[BACK] {6|n|OFF|ON} 	当查询选择了n行后,显示查询返回记录的数量 	
HEA[DING] {OFF|ON} 	决定是否列标题显示在报表中 	默认开启
LONG {80|n} 	设置显示 LONG 值时的最大宽度 	默认80个字符

获取更加可读性的报表,你可以通过使用下面的命令控制报表栏
命令 	描述
COL[UMN] 	控制列格式
TTI[TLE] [text|OFF|ON] 	指定每页报表顶部显示的标题
BTI[TLE] [text|OFF|ON] 	指定每页报表底部显示的脚注
BRE[AK] [ON report_element] 	限制重复的值和使用连接符将数据行分成几部分
实践1- verify新老语句的对比开关

show命令查看环境变量verify

SQL> show verify
verify ON

设置该环境变量为off状态

SQL> set verify off


SQL> show verify
verify OFF

SQL> select ename,sal from emp where sal>&p;
Enter value for p: 2000

ENAME		  SAL
---------- ----------
JONES		 2975
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
FORD		 3000

6 rows selected.

实践2- echo控制脚本执行时是否显示命令

SQL> show echo
echo OFF
SQL> list
  1* select ename,sal from emp where sal>&p
SQL> save 1.sql
Created file 1.sql
SQL> get 1.sql
  1* select ename,sal from emp where sal>&p
SQL> @1
Enter value for p: 2000
old   1: select ename,sal from emp where sal>&p
new   1: select ename,sal from emp where sal>2000

ENAME		  SAL
---------- ----------
JONES		 2975
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
FORD		 3000

6 rows selected.

SQL> set echo on
SQL> @1.sql
SQL> select ename,sal from emp where sal>&p
  2  /
Enter value for p: 2000
old   1: select ename,sal from emp where sal>&p
new   1: select ename,sal from emp where sal>2000

ENAME		  SAL
---------- ----------
JONES		 2975
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
FORD		 3000

6 rows selected.

实践3- arraysize

数据库取回数据的大小为15行

SQL> show arraysize
arraysize 15

arraysize最大值为5000

SQL> set arraysize 5000
SQL> set arraysize 5001
SP2-0267: arraysize option 5001 out of range (1 through 5000)

实践4-feedback

当查询选择了n行后,显示查询返回记录的数量

SQL> show feedback
FEEDBACK ON for 6 or more rows

SQL> set feedback on;
SQL> show feedback;
FEEDBACK ON for 1 or more rows
SQL> select * from salgrade;

     GRADE	LOSAL	   HISAL
---------- ---------- ----------
	 1	  700	    1200
	 2	 1201	    1400
	 3	 1401	    2000
	 4	 2001	    3000
	 5	 3001	    9999

5 rows selected.

SQL> set feedback off;
SQL> show feedback;
feedback OFF
SQL> set feedback 6;
SQL> show feedback;
FEEDBACK ON for 6 or more rows

实践5-heading决定是否列标题显示在报表中

SQL> show heading
heading ON
SQL> select * from salgrade;

     GRADE	LOSAL	   HISAL
---------- ---------- ----------
	 1	  700	    1200
	 2	 1201	    1400
	 3	 1401	    2000
	 4	 2001	    3000
	 5	 3001	    9999

SQL> set heading off;
SQL> select * from salgrade;

	 1	  700	    1200
	 2	 1201	    1400
	 3	 1401	    2000
	 4	 2001	    3000
	 5	 3001	    9999

SQL> set heading on;

实践6-long默认打印出80个字符

SQL> show long
long 80

打印emp表的元数据，发现不全

SQL> select dbms_metadata.get_ddl('TABLE','EMP') from dual;

DBMS_METADATA.GET_DDL('TABLE','EMP')
--------------------------------------------------------------------------------

  CREATE TABLE "SCOTT"."EMP"
   (	"EMPNO" NUMBER(4,0),
	"ENAME" VARCHAR2(10),

修改long的值

SQL> set long 50000

SQL> select dbms_metadata.get_ddl('TABLE','EMP') from dual;

DBMS_METADATA.GET_DDL('TABLE','EMP')
--------------------------------------------------------------------------------

  CREATE TABLE "SCOTT"."EMP"
   (	"EMPNO" NUMBER(4,0),
	"ENAME" VARCHAR2(10),
	"JOB" VARCHAR2(9),
	"MGR" NUMBER(4,0),
	"HIREDATE" DATE,
	"SAL" NUMBER(7,2),
	"COMM" NUMBER(7,2),
	"DEPTNO" NUMBER(2,0),
	 CONSTRAINT "PK_EMP" PRIMARY KEY ("EMPNO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE,
	 CONSTRAINT "FK_DEPTNO" FOREIGN KEY ("DEPTNO")
	  REFERENCES "SCOTT"."DEPT" ("DEPTNO") ENABLE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"

SQLPlus报表格式
实践1-列名换行

SQL> col ename heading 'first|name'
SQL> select ename,sal from emp;

first
name		  SAL
---------- ----------
SMITH		  800
ALLEN		 1600
WARD		 1250
JONES		 2975
MARTIN		 1250
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
TURNER		 1500
ADAMS		 1100
JAMES		  950
FORD		 3000
MILLER		 1300

14 rows selected.

实践2-给工资列加美元前缀

SQL> col sal for $99,999.99
SQL> select ename,sal from emp;

first
name		   SAL
---------- -----------
SMITH	       $800.00
ALLEN	     $1,600.00
WARD	     $1,250.00
JONES	     $2,975.00
MARTIN	     $1,250.00
BLAKE	     $2,850.00
CLARK	     $2,450.00
SCOTT	     $3,000.00
KING	     $5,000.00
TURNER	     $1,500.00
ADAMS	     $1,100.00
JAMES	       $950.00
FORD	     $3,000.00
MILLER	     $1,300.00

14 rows selected.

实践3-给sal和comm列设置美元前缀，列名居中显示

SQL> col sal justify c for $99,999.99
SQL> col comm justify c for $99,999.99

SQL> select ename,sal,comm from emp;

first
name	       SAL	  COMM
---------- ----------- -----------
SMITH	       $800.00
ALLEN	     $1,600.00	   $300.00
WARD	     $1,250.00	   $500.00
JONES	     $2,975.00
MARTIN	     $1,250.00	 $1,400.00
BLAKE	     $2,850.00
CLARK	     $2,450.00
SCOTT	     $3,000.00
KING	     $5,000.00
TURNER	     $1,500.00	      $.00
ADAMS	     $1,100.00
JAMES	       $950.00
FORD	     $3,000.00
MILLER	     $1,300.00

14 rows selected.

实践4-清空格式

SQL> col ename clear
SQL> col sal clear
SQL> col comm clear
SQL> select ename,sal,comm from emp;

ENAME		  SAL	    COMM
---------- ---------- ----------
SMITH		  800
ALLEN		 1600	     300
WARD		 1250	     500
JONES		 2975
MARTIN		 1250	    1400
BLAKE		 2850
CLARK		 2450
SCOTT		 3000
KING		 5000
TURNER		 1500	       0
ADAMS		 1100
JAMES		  950
FORD		 3000
MILLER		 1300

14 rows selected.

实践5-在上一条sql的基础上进行排序，再次调用用/

SQL> select deptno,ename from emp;

    DEPTNO ENAME
---------- ----------
	20 SMITH
	30 ALLEN
	30 WARD
	20 JONES
	30 MARTIN
	30 BLAKE
	10 CLARK
	20 SCOTT
	10 KING
	30 TURNER
	20 ADAMS
	30 JAMES
	20 FORD
	10 MILLER

14 rows selected.

SQL> a  order by deptno
  1* select deptno,ename from emp order by deptno
SQL> /

    DEPTNO ENAME
---------- ----------
	10 CLARK
	10 KING
	10 MILLER
	20 JONES
	20 FORD
	20 ADAMS
	20 SMITH
	20 SCOTT
	30 WARD
	30 TURNER
	30 ALLEN
	30 JAMES
	30 BLAKE
	30 MARTIN

14 rows selected.

实践6-BREAK 命令将行分成部分并限制重复的值

SQL> select deptno,ename from emp;

    DEPTNO ENAME
---------- ----------
	20 SMITH
	30 ALLEN
	30 WARD
	20 JONES
	30 MARTIN
	30 BLAKE
	10 CLARK
	20 SCOTT
	10 KING
	30 TURNER
	20 ADAMS
	30 JAMES
	20 FORD
	10 MILLER

14 rows selected.

SQL> break on deptno
SQL> /

    DEPTNO ENAME
---------- ----------
	20 SMITH
	30 ALLEN
	   WARD
	20 JONES
	30 MARTIN
	   BLAKE
	10 CLARK
	20 SCOTT
	10 KING
	30 TURNER
	20 ADAMS
	30 JAMES
	20 FORD
	10 MILLER

14 rows selected.

SQL> select deptno,ename from emp order by deptno;

    DEPTNO ENAME
---------- ----------
	10 CLARK
	   KING
	   MILLER
	20 JONES
	   FORD
	   ADAMS
	   SMITH
	   SCOTT
	30 WARD
	   TURNER
	   ALLEN
	   JAMES
	   BLAKE
	   MARTIN

14 rows selected.

清除break

SQL> clear break
breaks cleared

实践7-将结果集以报表的形式打印bti

SQL> show tti
ttitle OFF and is the first few characters of the next SELECT statement
SQL> show bti
btitle OFF and is the following 10 characters:
End report
SQL> tti 'Start Booboo'
SQL> bti 'End Booboo'
SQL> set pagesize 25
SQL> select ename,sal,deptno from emp;

Mon Jul 31										       page    1
						      Start Booboo

ENAME		  SAL	  DEPTNO
---------- ---------- ----------
SMITH		  800	      20
ALLEN		 1600	      30
WARD		 1250	      30
JONES		 2975	      20
MARTIN		 1250	      30
BLAKE		 2850	      30
CLARK		 2450	      10
SCOTT		 3000	      20
KING		 5000	      10
TURNER		 1500	      30
ADAMS		 1100	      20
JAMES		  950	      30
FORD		 3000	      20
MILLER		 1300	      10




						       End Booboo

14 rows selected.

注意：以上和sql语句无关，都是sqlplus带来的一些特性
SQLPlus的spool脱机模式

    spool 1.txt 开始脱机
    spool off 结束脱机存盘
    spool 1.txt append 追加脱机
    spool off 结束脱机存盘

SQL> spool 1.txt
SQL> select * fro salgrade;
select * fro salgrade
         *
ERROR at line 1:
ORA-00923: FROM keyword not found where expected


SQL> select * from salgrade;

     GRADE	LOSAL	   HISAL
---------- ---------- ----------
	 1	  700	    1200
	 2	 1201	    1400
	 3	 1401	    2000
	 4	 2001	    3000
	 5	 3001	    9999

SQL> spool off
SQL> spool 1.txt append
SQL> select * from dept;

    DEPTNO DNAME	  LOC
---------- -------------- -------------
	10 ACCOUNTING	  NEW YORK
	20 RESEARCH	  DALLAS
	30 SALES	  CHICAGO
	40 OPERATIONS	  BOSTON

SQL> spool off


[oracle@oracle0 ~]$ cat 1.txt
SQL> select * fro salgrade;
select * fro salgrade
         *
ERROR at line 1:
ORA-00923: FROM keyword not found where expected


SQL> select * from salgrade;

     GRADE      LOSAL      HISAL                                                                                        
---------- ---------- ----------                                                                                        
         1        700       1200                                                                                        
         2       1201       1400                                                                                        
         3       1401       2000                                                                                        
         4       2001       3000                                                                                        
         5       3001       9999                                                                                        

SQL> spool off
SQL> select * from dept;

    DEPTNO DNAME          LOC                                                                                           
---------- -------------- -------------                                                                                 
        10 ACCOUNTING     NEW YORK                                                                                      
        20 RESEARCH       DALLAS                                                                                        
        30 SALES          CHICAGO                                                                                       
        40 OPERATIONS     BOSTON                                                                                        

SQL> spool off

SQLPlus行转列

一直以来，觉得MySQL中使用\G参数改变输出结果集的显示方式非常好用，尤其是在命令行界面。但是ORACLE数据库没有这个功能，今天在搜索到Tom大师的一篇博文时，发现大师用一个存储过程print_table实现了类似这样的功能。
只是我们这些凡夫俗子不知道而已，特意整理在此，方便自己或有需要的人以后查看。

CREATE OR REPLACE PROCEDURE print_table(p_query IN VARCHAR2)
AUTHID CURRENT_USER
IS
 l_thecursor INTEGER DEFAULT dbms_sql.open_cursor;
 l_columnvalue VARCHAR2(4000);
 l_status  INTEGER;
 l_desctbl  dbms_sql.desc_tab;
 l_colcnt  NUMBER;
BEGIN
 EXECUTE IMMEDIATE 'alter session set nls_date_format=''dd-mon-yyyy hh24:mi:ss'' ';

 dbms_sql.parse(l_thecursor, p_query, dbms_sql.native);

 dbms_sql.describe_columns (l_thecursor, l_colcnt, l_desctbl);

 FOR i IN 1 .. l_colcnt LOOP
  dbms_sql.define_column (l_thecursor, i, l_columnvalue, 4000);
 END LOOP;

 l_status := dbms_sql.EXECUTE(l_thecursor);

 WHILE ( dbms_sql.Fetch_rows(l_thecursor) > 0 ) LOOP
  FOR i IN 1 .. l_colcnt LOOP
   dbms_sql.column_value (l_thecursor, i, l_columnvalue);

   dbms_output.Put_line (RPAD(L_desctbl(i).col_name, 30)
         || ': '
         || l_columnvalue);
  END LOOP;

  dbms_output.put_line('-----------------');
 END LOOP;

 EXECUTE IMMEDIATE 'alter session set nls_date_format=''dd-MON-rr'' ';
EXCEPTION
 WHEN OTHERS THEN
    EXECUTE IMMEDIATE
    'alter session set nls_date_format=''dd-MON-rr'' ';

    RAISE;
END;
/

测试

SQL> execute print_table('select * from v$session where rownum < 2');
SADDR			      : 00000000DF62D4B8
SID			      : 1
SERIAL# 		      : 1
AUDSID			      : 0
PADDR			      : 00000000DF4C9A20
USER#			      : 0
USERNAME		      :
COMMAND 		      : 0
OWNERID 		      : 2147483644
TADDR			      :
LOCKWAIT		      :
STATUS			      : ACTIVE
SERVER			      : DEDICATED
SCHEMA# 		      : 0
SCHEMANAME		      : SYS
OSUSER			      : oracle
PROCESS 		      : 30539
MACHINE 		      : NB-flexgw1
PORT			      : 0
TERMINAL		      : UNKNOWN
PROGRAM 		      : oracle@NB-flexgw1 (GEN0)
TYPE			      : BACKGROUND
SQL_ADDRESS		      : 00
SQL_HASH_VALUE		      : 0
SQL_ID			      :
SQL_CHILD_NUMBER	      : 0
SQL_EXEC_START		      :
SQL_EXEC_ID		      :
PREV_SQL_ADDR		      : 00
PREV_HASH_VALUE 	      : 0
PREV_SQL_ID		      :
PREV_CHILD_NUMBER	      : 0
PREV_EXEC_START 	      :
PREV_EXEC_ID		      :
PLSQL_ENTRY_OBJECT_ID	      :
PLSQL_ENTRY_SUBPROGRAM_ID     :
PLSQL_OBJECT_ID 	      :
PLSQL_SUBPROGRAM_ID	      :
MODULE			      :
MODULE_HASH		      : 0
ACTION			      :
ACTION_HASH		      : 0
CLIENT_INFO		      :
FIXED_TABLE_SEQUENCE	      : 0
ROW_WAIT_OBJ#		      : -1
ROW_WAIT_FILE#		      : 0
ROW_WAIT_BLOCK# 	      : 0
ROW_WAIT_ROW#		      : 0
TOP_LEVEL_CALL# 	      : 0
LOGON_TIME		      : 18-dec-2019 19:02:50
LAST_CALL_ET		      : 89209
PDML_ENABLED		      : NO
FAILOVER_TYPE		      : NONE
FAILOVER_METHOD 	      : NONE
FAILED_OVER		      : NO
RESOURCE_CONSUMER_GROUP       :
PDML_STATUS		      : DISABLED
PDDL_STATUS		      : DISABLED
PQ_STATUS		      : DISABLED
CURRENT_QUEUE_DURATION	      : 0
CLIENT_IDENTIFIER	      :
BLOCKING_SESSION_STATUS       : NO HOLDER
BLOCKING_INSTANCE	      :
BLOCKING_SESSION	      :
FINAL_BLOCKING_SESSION_STATUS : NO HOLDER
FINAL_BLOCKING_INSTANCE       :
FINAL_BLOCKING_SESSION	      :
SEQ#			      : 29733
EVENT#			      : 7
EVENT			      : rdbms ipc message
P1TEXT			      : timeout
P1			      : 300
P1RAW			      : 000000000000012C
P2TEXT			      :
P2			      : 0
P2RAW			      : 00
P3TEXT			      :
P3			      : 0
P3RAW			      : 00
WAIT_CLASS_ID		      : 2723168908
WAIT_CLASS#		      : 6
WAIT_CLASS		      : Idle
WAIT_TIME		      : 0
SECONDS_IN_WAIT 	      : 1
STATE			      : WAITING
WAIT_TIME_MICRO 	      : 1383807
TIME_REMAINING_MICRO	      : 1616193
TIME_SINCE_LAST_WAIT_MICRO    : 0
SERVICE_NAME		      : SYS$BACKGROUND
SQL_TRACE		      : DISABLED
SQL_TRACE_WAITS 	      : FALSE
SQL_TRACE_BINDS 	      : FALSE
SQL_TRACE_PLAN_STATS	      : FIRST EXEC
SESSION_EDITION_ID	      : 0
CREATOR_ADDR		      : 00000000DF4C9A20
CREATOR_SERIAL# 	      : 1
ECID			      :
-----------------

PL/SQL procedure successfully completed.

SQLPLUS需要开启参数serveroutput，才能打印存储过程的结果。

SQL> set serveroutput on
SQL> exec print_table('select * from scott.t01 where rownum < 2')
EMPNO			      : 7369
ENAME			      : SMITH
JOB			      : CLERK
MGR			      : 7902
HIREDATE		      : 17-dec-1980 00:00:00
SAL			      : 800
COMM			      :
DEPTNO			      : 20
-----------------

PL/SQL procedure successfully completed.

SQL语句-DML语句的使用

DML的分类

    增 insert into
    删 delete from （对比truncate）
    改 update
    合并行 merge
    控制事务处理

insert

使用 INSERT 语句可在表中添加新行:

INSERT INTO table [(column [, column...])]
VALUES (value [, value...]);

update

使用 UPDATE 语句修改表中的现有值:

UPDATE table
SET column = value [, column = value, ...]
[WHERE condition];

如果需要,可以一次更新多行。
delete

使用 DELETE 语句可以从表中删除现有行:

DELETE [FROM] table
[WHERE condition];

truncate

TRUNCATE 语句

    从表中删除所有行,使表为空并保留表结构不变
    是数据定义语言 (DDL) 语句而不是 DML 语句,无法轻易将其取消
    语法:

TRUNCATE TABLE table_name;
事务

    commit 提交
    rollback 回滚到事务开始之前
    savepoint A 保存状态
    rollback to savepoint A 回滚到状态A

操作实践
1. 向emp表中添加新行：

对所有列赋值

desc emp
insert into emp values (1,'Tom','CLERK',7698,to_date('yyyy-mm-dd','2016-08-25'),1450,null,30);

对指定的列赋值

insert into emp (empno,ename) values (2,'Jerry');

sql脚本inst.sql

insert into dept values (&deptno,upper('&dname'),upper('&loc'));

2. 子查询拷贝行

emp表中有奖金的员工存放在新创建的表bonus中
insert into bonus select ENAME,JOB,SAL,COMM from emp where comm>0;

3. 修改表中数据

smith工资涨百分之10
update emp set sal=sal*1.1 where ename='SMITH';

4. 向虚拟表中插入行

insert into (select empno,ename,deptno from emp where deptno=10)
values (2,'Alvin',20);

通过sql脚本来执行`ins10.sql`


```sql
insert into (select * from emp where deptno=10 with check option)
values (&empno,'&ename','&job',&mgr,'&hiredate',&sal,&comm,&deptno);

5. with check option 选项

设置with check option选项
SQL> insert into (select * from emp where deptno=10 with check option) values (901,'booboo2','dba',7782,sysdate,7000,8000,10);

1 row created.

SQL> select * from emp where deptno=10;
     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
       901 booboo2    dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10

SQL> insert into (select * from emp where deptno=10 with check option) values (901,'booboo2','dba',7782,sysdate,7000,8000,20);
insert into (select * from emp where deptno=10 with check option) values (901,'booboo2','dba',7782,sysdate,7000,8000,20)
                           *
ERROR at line 1:
ORA-01402: view WITH CHECK OPTION where-clause violation

如果设置了该选项，那么插入的新记录，必须和where后面的匹配，比如案例中，where指定了部门为10，那么插入的也必须为10部门的记录。
6. merge合并行

    数据源：emp
    目标表：copy_emp

create table copy_emp as select * from emp where deptno=10;

    matched--> 目标表中的主键值在数据源中被找到
    not matched --> 数据源中主键在目标表中不存在

merge into copy_emp c
using emp e
on (c.empno=e.empno)
when matched then
update set
c.ename=e.ename,
c.job=e.job,
c.mgr=e.mgr,
c.hiredate=e.hiredate,
c.sal=e.sal,
c.comm=e.comm,
c.deptno=e.deptno
when not matched then
insert values
(e.empno,
e.ename,
e.job,
e.mgr,
e.hiredate,
e.sal,
e.comm,
e.deptno);

操作记录

SQL> create table copy_emp as select * from emp where deptno=10;

Table created.

SQL> merge into copy_emp c
  2  using emp e
  3  on (c.empno=e.empno)
when matched then
update set
c.ename=e.ename,
c.job=e.job,
c.mgr=e.mgr,
c.hiredate=e.hiredate,
c.sal=e.sal,
c.comm=e.comm,
c.deptno=e.deptno
when not matched then
insert values
(e.empno,
e.ename,
e.job,
e.mgr,
e.hiredate,
e.sal,
e.comm,
 22  e.deptno);

16 rows merged.

SQL> select * from copy_emp;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
       901 booboo2    dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10
      7844 TURNER     SALESMAN	      7698 08-SEP-81	   1500 	 0	   30
      7521 WARD       SALESMAN	      7698 22-FEB-81	   1250        500	   30
      7654 MARTIN     SALESMAN	      7698 28-SEP-81	   1250       1400	   30
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3000 		   20
      7698 BLAKE      MANAGER	      7839 01-MAY-81	   2850 		   30
      7566 JONES      MANAGER	      7839 02-APR-81	   2975 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30
      7902 FORD       ANALYST	      7566 03-DEC-81	   3000 		   20
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7876 ADAMS      CLERK	      7788 23-MAY-87	   1100 		   20
      7900 JAMES      CLERK	      7698 03-DEC-81	    950 		   30

16 rows selected.

源表进行了修改

SQL> insert into emp (empno,ename,sal) values (1,'Alvin',1400);

1 row created.

SQL> update emp set sal=1111 where empno=7788;

1 row updated.

目标表与源表不一致了

SQL> select * from copy_emp;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
       901 booboo2    dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10
      7844 TURNER     SALESMAN	      7698 08-SEP-81	   1500 	 0	   30
      7521 WARD       SALESMAN	      7698 22-FEB-81	   1250        500	   30
      7654 MARTIN     SALESMAN	      7698 28-SEP-81	   1250       1400	   30
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3000 		   20
      7698 BLAKE      MANAGER	      7839 01-MAY-81	   2850 		   30
      7566 JONES      MANAGER	      7839 02-APR-81	   2975 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30
      7902 FORD       ANALYST	      7566 03-DEC-81	   3000 		   20
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7876 ADAMS      CLERK	      7788 23-MAY-87	   1100 		   20
      7900 JAMES      CLERK	      7698 03-DEC-81	    950 		   30

16 rows selected.

SQL> select * from emp;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
       901 booboo2    dba	      7782 31-JUL-17	   7000       8000	   10
	 1 Alvin					   1400
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30
      7521 WARD       SALESMAN	      7698 22-FEB-81	   1250        500	   30
      7566 JONES      MANAGER	      7839 02-APR-81	   2975 		   20
      7654 MARTIN     SALESMAN	      7698 28-SEP-81	   1250       1400	   30
      7698 BLAKE      MANAGER	      7839 01-MAY-81	   2850 		   30
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7788 SCOTT      ANALYST	      7566 19-APR-87	   1111 		   20
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10
      7844 TURNER     SALESMAN	      7698 08-SEP-81	   1500 	 0	   30
      7876 ADAMS      CLERK	      7788 23-MAY-87	   1100 		   20
      7900 JAMES      CLERK	      7698 03-DEC-81	    950 		   30
      7902 FORD       ANALYST	      7566 03-DEC-81	   3000 		   20
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10


17 rows selected.

再次合并

merge into copy_emp c
using emp e
on (c.empno=e.empno)
when matched then
update set
c.ename=e.ename,
c.job=e.job,
c.mgr=e.mgr,
c.hiredate=e.hiredate,
c.sal=e.sal,
c.comm=e.comm,
c.deptno=e.deptno
when not matched then
insert values
(e.empno,
e.ename,
e.job,
e.mgr,
e.hiredate,
e.sal,
e.comm,
e.deptno);

17 rows merged.

合并后与源表一致

SQL> select * from copy_emp;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
       901 booboo2    dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10
      7844 TURNER     SALESMAN	      7698 08-SEP-81	   1500 	 0	   30
      7521 WARD       SALESMAN	      7698 22-FEB-81	   1250        500	   30
      7654 MARTIN     SALESMAN	      7698 28-SEP-81	   1250       1400	   30
      7788 SCOTT      ANALYST	      7566 19-APR-87	   1111 		   20
      7698 BLAKE      MANAGER	      7839 01-MAY-81	   2850 		   30
      7566 JONES      MANAGER	      7839 02-APR-81	   2975 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30
      7902 FORD       ANALYST	      7566 03-DEC-81	   3000 		   20
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7876 ADAMS      CLERK	      7788 23-MAY-87	   1100 		   20
      7900 JAMES      CLERK	      7698 03-DEC-81	    950 		   30
	 1 Alvin					   1400

17 rows selected.

这是数据仓库的一些用法

修改目标表后再此合并

SQL> update copy_emp set sal=1499 where empno=1;

1 row updated.

SQL> select * from emp where empno=1;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
	 1 Alvin					   1400

SQL> select * from copy_emp where empno=1;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
	 1 Alvin					   1499

merge into copy_emp c
using emp e
on (c.empno=e.empno)
when matched then
update set
c.ename=e.ename,
c.job=e.job,
c.mgr=e.mgr,
c.hiredate=e.hiredate,
c.sal=e.sal,
c.comm=e.comm,
c.deptno=e.deptno
when not matched then
insert values
(e.empno,
e.ename,
e.job,
e.mgr,
e.hiredate,
e.sal,
e.comm,
e.deptno);

17 rows merged.

SQL> select * from emp where empno=1;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
	 1 Alvin					   1400

SQL> select * from copy_emp where empno=1;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
	 1 Alvin					   1400

SQL语句-事务和锁机制

数据库事务简介

Oracle服务器基于事务保证数据的一致性。当改变数据的时候,事务给你更加灵活的控制,并且在发生用户进程错误或者系统错误的情况下,保证事件中数据的一致性。

事务是由保证对数据改变一致性的DML语句组成。举例来说,两个帐户之间的资金转帐应当保证借方帐户和贷方帐户之间数额一样。两个动作应该同时成功或者失败。没有借方贷方不能够提交。

事务的四大特性：ACID

A：原子性

C：一致性

I：隔离级别

D：持久性
事务的原子性

SQL的分类：
类型 	描述
数据操纵语言(DML) 	由一定数量的 DML 命令组成, Oracle服务器将他们视为单一实体或者一个逻辑单元
数据定义语言(DDL) 	只由一个 DDL 语言组成
数据控制语言(DCL) 	只有一个 DCL 语言组成
数据查询语言(DQL) 	只有一个 select 语句组成

事务何时开始和结束?

当遇到第一个 DML 命令事务开始,遇到下面的情况事务结束:

    COMMIT 或者 ROLLBACK 命令被执行
    一个 DDL 命令,比如 CREATE 被执行
    一个DCL命令被执行
    用户退出 iSQL*Plus
    机器发生错误或者系统崩溃

在一个事务结束后,下一个执行的 SQL 命令自动开始一个新的事务。

DDL命令或者DCL命令是自动提交的,因此是显式的结束一个事务。
隐式事务

DDL命令或者DCL命令是自动提交的,因此是隐式事务，自动提交。

    自动提交
    自动回退

    注意:在 iSQLPlus 中第三个命令 AUTOCOMMIT 可以将其关闭或者打开。如果设置成为打开的状态,每个独立的 DML 命令只要一执行就会被提交。你不能回退这个变化。如果设置成关, COMMIT 命令仍旧需要显式的执行。当你执行 DDL 命令或者当你退出iSQLPlus ,COMMIT命令就会被执行。

    系统失败:当由于一个系统的错误导致一个事务中断,整个事务将会被自动回退。这个将会阻止对数据不期望的改变发生,并将表恢复到最后一次提交前的状态。通过这种方式, Oracle 服务器保证数据的完整性。

在 iSQLPlus ,单击 Exit 按钮完成从一个会话中的正常退出。使用 SQLPlus ,通过在提示符下面输入 EXIT 命令完成一个正常的退出，关闭窗口被认为是一个不正常的退出。
显式事务

由DCL组成，可以使用 COMMIT, SAVEPOINT 和 ROLLBACK 命令控制事务的逻辑。
命令 	描述
COMMIT 	通过对当前所有未决的数据永久性改变,结束事务
SAVEPOINT name 	对当前的事务做一个检查点
ROLLBACK 	通过放弃所有未决的数据改变 ROLLBACK当前的事务
ROLLBACK TO SAVEPOINT name 	ROLLBACK TO SAVEPOINT回退当前的事务到指定的检查点。因此在你即将回退到的检查点之后创建的检查点和所作的改变都会被放弃

注意: SAVEPOINT 不是一个标准的 ANSI SQL.
SAVEPOINT和ROLLBACK TO SAVEPOINT回退改变到标记处

你可以使用 SAVEPOINT 命令在当前会话中创建一个标记,将一个事务分成几个部分。你可以使用 ROLLBACK TO SAVEPOINT 丢弃所有未决的改变到标记处。

如果你创建的第二个检查点的名称和第一个相同,那么早前的检查点就会被删除。
COMMIT或者 ROLLBACK 提交改变

直到事务提交之前,事务期间对数据所做的改变都是临时的。

在 COMMIT 或者 ROLLBACK 命令执行前数据的状态是:

    数据操作主要影响数据库的缓冲区;因此先前的数据状态可以被恢复。
    当前的用户通过查询表可以预览对数据操作的结果。
    其他的用户不能够浏览当前用户对数据操作的结果。 Oracle 服务器制定的读一致性是确保每个用户看到的是自上一次提交后的数据。
    受影响的行被锁定;其他的用户不能够改变受影响行的数据。

使用 COMMIT 命令可以使所有未决的改变永久化。在 COMMIT 命令执行之后:

    数据的改变被写入到数据库中
    先前数据的状态永久性的丢失
    所有的用户可以浏览事务的结果
    受影响行上面的锁被释放;对于其他用户来说,该行现在可以被执行新的数据修改。
    所有的检查点被清除

ROLLBACK回退改变

通过执行 ROLLBACK 命令回退所有未决的改变。 ROLLBACK 命令执行后:

    数据的改变被撤销
    先前的数据状态被还原
    受影响的行上面的锁被释放

隔离级别和读一致性
Oracle的隔离级别

Oracle的隔离级别为：RC 可提交读。

数据库用户访问数据库有两种方式:

    读操作( SELECT 命令)
    写操作( INSERT, UPDATE 和 DELETE 命令)

你需要读一致性以便下面的发生:

    数据库读和写被确保数据的一致性视图
    读取不会看到数据正在被修改的进程
    写将会确保对数据库的操作一致性
    一个写入所作的改变不会破坏或者和其他的写入冲突

读一致性的目的就是在DML操作开始之前,确保每个用户看到的是最后一次提交后数据存在的状态。
读一致性的执行

读一致性是自动执行的。它保存数据库拷贝的一部分在回退段中。当一个插入,更新或者删除操作被执行,数据库会在数据被改变并写入到回退段之前做一个数据的拷贝。

所有的读取,除了执行改变的那个,仍旧看到变化开始之前的数据库存在的状态;他们看到的是回退段中数据的快照。

在改变被提交给数据库之前,只有修改数据的用户能够看到数据库的改变。其他的所有人看到的都是回退段中的快照。这个可以保证读取到数据一致的数据读取不会经历改变。

当一个DML语句被提交,对数据库所做的改变多于任何执行 SELECT 命令的用户都是看见的。被“老的”数据占用的回退段中的空间被释放以便重新使用。

如果事务被回退,改变将会被撤销

    原始的,回退段中旧有的数据将会被写回到表中
    所有的用户看到的是事务开始之前的数据库存在的状态

什么是锁

锁是一种机制,防止访问同一个资源的事物之间的破坏性的冲突。同一个资源或者是一个用户的对象(比如说表和视图)或者对于用户不可见的系统对象(比如共享的数据结构或者数据字典行)

Oracle 数据库是如何锁数据的?

锁是自动执行,不需要用户干预的。对于SQL命令隐式锁是必需的,这取决于所需的操作。

除了 SELECT 命令隐式锁对所有的SQL命令都发生。

用户可以手动锁定数据,这个称为显示锁。
DML 锁

当执行数据操纵语言(DML)操作的时候, Oracle 服务器通过 DML 锁提供数据同时访问,DML 锁发生在两个级别:

    DML操作期间在表级共享锁是自动获得的。共享锁模式,几个事务可以取得同一资源的共享锁。
    被DML命令修改的每行自动获得一个独占锁。独占锁防止被修改的行被其他的事务修改,直到该事务被提交或者回滚。该锁确保没有其他的用户在同一时间修改同一行,并覆盖掉被另一个用户所作的还没有提交的改变。

注意: DDL 发生在当你修改数据库对象的时候,比如说一张表。
操作实践

    事务的提交和回滚

SQL> insert into booboo select * from emp where empno=900;

1 row created.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10

SQL> roll back;
Rollback complete.
SQL> select * from booboo;

no rows selected

SQL> insert into booboo select * from emp where empno=900;

1 row created.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10

SQL> savepoint t1;

Savepoint created.

SQL> insert into booboo select * from emp where empno=7782;

1 row created.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10

SQL> savepoint t2;

Savepoint created.

SQL> insert into booboo select * from emp where empno=7839;

1 row created.

SQL> savepoint t3;

Savepoint created.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10

SQL> insert into booboo select * from emp where empno=7934;

1 row created.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10

SQL> rollback to savepoint t3;

Rollback complete.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10
      7839 KING       PRESIDENT 	   17-NOV-81	   5000 		   10

SQL> rollback to savepoint t2;

Rollback complete.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2450 		   10

SQL> rollback to savepoint t1;

Rollback complete.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10

    读一致性

oracle默认的事务隔离级别为RC 已提交读，还支持串行读

事务未提交时，只有事务内部可见

    oracle做任何操作都会有一个时间

    比如用户9：00开始查询，9：30才结束查询，在9：15进行了写操作，写操作对9点查询来说不应该读到

    oracle中通过SCN（system change number）系统变更号来做标记，就相当于时间，伴随着所有操作

    SCN是oracle中顺序增长的一个数字，用来精确区别操作的先后顺序，使用6字节 48位 来记录

SQL> conn / as sysdba
Connected.
SQL> select current_scn from v$database;

CURRENT_SCN
-----------
    1290680

SQL> /

CURRENT_SCN
-----------
    1290699

SQL> /

CURRENT_SCN
-----------
    1290702



SQL> select scn_to_timestamp(1290702) from dual;

SCN_TO_TIMESTAMP(1290702)
---------------------------------------------------------------------------
02-AUG-17 11.38.03.000000000 AM

SQL> select to_char(scn_to_timestamp(1290702),'YYYY-mm-dd HH:MM:SS') from dual;

TO_CHAR(SCN_TO_TIME
-------------------
2017-08-02 11:08:03

如果scn比select的scn高，则不读取，来实现一致性读

--会话1
SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10

--会话2
SQL> update booboo set sal=1 where empno=900;

1 row updated.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	      1       8000	   10

--会话1
SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	   7000       8000	   10

--会话2
SQL> commit;

Commit complete.

--会话1
SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	      1       8000	   10

    锁机制

--会话1
SQL> update booboo set sal=2 where empno=900;

1 row updated.

SQL> select * from booboo;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
       900 booboo     dba	      7782 31-JUL-17	      2       8000	   10

--会话2
SQL> update booboo set sal=1 where empno=9
出现 dengda

SCN
scn_to_timestamp()函数

scn_to_timestamp()函数可以将scn转换日期时间
查看物理文件的scn号

set linesize 200
column name format a50
select file#,name,checkpoint_change#,to_char(scn_to_timestamp(checkpoint_change#),'YYYY-mm-dd HH:MM:SS') hm from v$datafile;
select group#,first_change#,to_char(scn_to_timestamp(first_change#),'YYYY-mm-dd HH:MM:SS') hm from v$log;
select name,current_scn,to_char(scn_to_timestamp(current_scn),'YYYY-mm-dd HH:MM:SS') hm from v$database;

SQL> select group#,first_change#,to_char(scn_to_timestamp(first_change#),'YYYY-mm-dd HH:MM:SS') hm from v$log;

    GROUP# FIRST_CHANGE# HM
---------- ------------- -------------------
	 1	  276076 2019-11-24 03:11:09
	 2	  197609 2019-11-10 03:11:09
	 3	  224760 2019-11-10 04:11:15

SQL> select name,current_scn,to_char(scn_to_timestamp(current_scn),'YYYY-mm-dd HH:MM:SS') hm from v$database;

NAME	  CURRENT_SCN HM
--------- ----------- -------------------
BOOBOO	       276342 2019-11-24 03:11:39


SQL语句-DDL管理5大对象

管理的对象

    表：存储数据
    视图：一张或多张表的数据子集
    序列
    索引
    同义词

对象命名规则

    由数字、字母、_、$、#组成
    表名和列名必须以字母开头，长度为1-30个字符
    同一个用户不能拥有两个同名的对象
    名字中不能使用Oracle服务器的保留字
    不区分大小写
    双引号打破规则

管理表
表的分类

    用户表:由用户创建和维护的表的集和；包含用户信息
    数据字典:由oracle服务器创建和维护的表的集和；包含数据库信息；用户记录oracle自己工作属性和状态的

数据字典分类 	前缀 	描述 	备注
字典表 	user_ 	包含有关用户拥有对象的信息 	当前用户所拥有的rw
字典表 	all_ 	包含所有用户可以访问的表的信息（对象表和相关的表） 	当前用户所拥有的rw以及有权力查看ro的对象的信息
字典表 	dba_ 	受限制视图，只能被DBA角色的人访问 	数据库管理员才有权限查看
动态性能视图 	v$ 	动态视图，数据库服务器性能，内存和锁 	初始化在内存中，c语言的结构数组，作为排错和优化的

--scott/tiger
--scott用户拥有的表rw权限
SQL> select table_name from user_tables;

TABLE_NAME
------------------------------
T01
SALGRADE
BONUS
EMP
DEPT

--scott用户拥有的rw以及可查看ro的对象
SQL> select table_name from all_tables;

TABLE_NAME
------------------------------
DUAL
SYSTEM_PRIVILEGE_MAP
TABLE_PRIVILEGE_MAP
STMT_AUDIT_OPTION_MAP
AUDIT_ACTIONS
WRR$_REPLAY_CALL_FILTER
HS_BULKLOAD_VIEW_OBJ
HS$_PARALLEL_METADATA
HS_PARTITION_COL_NAME
HS_PARTITION_COL_TYPE
HELP
...省略

--sysdba用户查看所有的对象
SQL> select table_name from dba_tables;
...省略
TABLE_NAME
------------------------------
LOGMNRC_DBNAME_UID_MAP
DIMENSION_EXCEPTIONS
AQ$_STREAMS_QUEUE_TABLE_L
AQ$_ORDERS_QUEUETABLE_L

2864 rows selected.

--sysdba用户查看scn
SQL> select current_scn from v$database;

CURRENT_SCN
-----------
    1134479

数据类型
数据类型 	描述
varchar2(size) 	可变长度字符数据
char(size) 	固定长度字符数据
number(p,s) 	可变长度数字数据
date 	日期和时间数值
long 	可变长度字符数据，最大2G
clob 	字符数据，最大到4G
raw and long raw 	原始二进制数据
blob 	二进制数，最大到4G
bfile 	存储到外部文件中的二进制数，最大到4G
rowid 	表示行在表中的唯一标识
表操作
创建表

create table t01 (id number(3),name varchar2(12));
create table t02 (id number,name varchar2(12),salary number(7,2) default 1000);

查看表的结构

desc t01;

子查询建表拷贝行

create table t03 as select empno,ename,sal,deptno from emp where deptno=30;

子查询建表拷贝表结构

create table t03 as select empno,ename,sal,deptno from emp where 1=0;

创建事务级临时表

commit 数据消失,表结构共享，数据是每个会话私有的

create global temporary table temp01 as select * from emp;

创建会话级临时表

connect & disconnect 数据消失

create global temporary table temp02 on commit preserve rows as select * from emp;

增加列

alter table t03 add (hiredate date);
alter table t03 add (loc varchar2(10));

修改列

alter table t03 modify (loc varchar2(13));
alter table t03 modify (hiredate date default sysdate);

重命名列

alter table t03 rename column loc to location;

删除列

alter table t03 drop (hiredate);

在业务高峰期删除列分为两步

    系统繁忙时设置列为未使用状态：（不产生IO，在字典中将该列屏蔽掉）

alter table t03 set unused column sal;

    系统不繁忙时删除未使用状态的列：（产生IO）

alter table t03 drop unused columns;

对列添加注释

comment on column t03.ename is 'first name';
select COLUMN_NAME,COMMENTS from user_col_comments where TABLE_NAME='T03';

对表添加注释

comment on table t03 is 'employees copy';
select COMMENTS from user_tab_comments where TABLE_NAME='T03';

重命名表

rename t03 to t04;

截断表

truncate table t04;

清空表中所有数据，不记录数据的老镜像，直接将表变成初始化状态
将表放入回收站

drop table t02;

将回收站对象还原

SQL> show recyclebin
SQL> flashback table t02 to before drop;

彻底删除表

drop table t01 purge;

清空回收站

purge recyclebin;

管理约束

    not null 非空
    unique 唯一键
    primary key 主键（非空和唯一）
    foreign key 外键（基于主键）
    check （指定的一个条件必须为真）

建表时直接启用约束，列级别启用约束，约束产用系统命名

create table t01 (id number not null);
select CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCH_CONDITION from user_constraints where TABLE_NAME='T01';
select constraint_name,column_name from user_cons_columns where table_name='T01';

建表时直接启用约束，列级别启用约束

create table t01 (id number constraint nn_t01_id not null);

    not null约束只能在列级别启用

启用唯一键约束

create table t01 (id number constraint uk_t01_id unique);

启用主键约束

create table t01 (id number constraint pk_t01_id primary key);

启用外键约束

create table t02 (id number constraint fk_t02_id references t01);
select CONSTRAINT_NAME,CONSTRAINT_TYPE,R_CONSTRAINT_NAME from user_constraints where TABLE_NAME='T02';

启用check约束

create table t03 (id number,salary number constraint ck_t03_sal check (salary>1000));
select CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCH_CONDITION from user_constraints where TABLE_NAME='T03';

外键的级联操作

使用on delete set null有一点需要注意的是，被参照的其他表的那一列必须能够被赋空，不能有not null约束，对于上面的例子来说是emp中dept列一定不能有not null约束，
如果已经定义了not null约束，又使用了on delete set null来删除被参照的数据时，将会发生：ORA-01407: 无法更新 (”DD”.”EMP”.”DEPT”) 为 NULL的错误。

总的来讲on delete cascade和on delete set null的作用是用来处理级联删除问题的，如果你需要删除的数据被其他数据所参照，那么你应该决定到底希望oracle怎么处理那些参照这些即将要删除数据的数据的，你可以有三种方式：

    禁止删除。这也是oracle默认的
    将那些参照本值的数据的对应列赋空，这个需要使用on delete set null关键字
    将那些参照本值的数据一并删除，这个需要使用on delete cascade关键字

alter table t02 drop constraint FK_T02_ID;
alter table t02 add constraint FK_T02_ID foreign key (id) references t01 on delete set null;
alter table t02 add constraint FK_T02_ID foreign key (id) references t01 on delete cascade;

查看约束状态

select CONSTRAINT_NAME,STATUS,VALIDATED from user_constraints where table_name='T01';

启用|关闭约束

    ENABLED VALIDATED
    ENABLED NOT VALIDATED
    DISABLED NOT VALIDATED
    DISABLED VALIDATED:不影响子表数据的前提下重建父表

alter table t02 modify constraint FK_T02_ID disable;
alter table t02 modify constraint FK_T02_ID enable;
alter table t02 modify constraint FK_T02_ID enable novalidate; --不限制老数据
alter table t02 modify constraint FK_T02_ID disable validate;

create table t04 (x int constraint u unique);
insert into t04 values (1);
alter table t04 mdify constraint u disable;
insert into t04 values (1);
alter table t04 mdify constraint u enable novalidate;
create index i_t04_x on t04 (x);

约束的禁用和启用文档

课堂练习题

create table emp01 (
    emp_no number(2) constraint emp_emp_no_pk primary key,
    ename varchar2(15), 
    salary number(8,2), 
    mgr_no number(2)
);

新建表emp01，其中emp_no上有一个主键 emp_emp_no_pk
alter table emp01 add constraint emp_mgr_fk
    foreign key (mgr_no)
    references emp01(emp_no)
    on delete set null;
新建一个外键 emp_mgr_fk，`on delete set null` 代表 删除emp_no时，mgr_no不删除变为null；

alter table emp01 disable constraint emp_emp_no_pk cascade;
禁用主键时，主键和外键都被禁用
为何此处要有参数 cascade ？

如果FOREIGN KEYs引用a UNIQUE或PRIMARY KEY，则必须在CASCADE CONSTRAINTS语句中包括该子句DROP，否则无法删除该约束。

alter table emp01 enable constraint emp_emp_no_pk;
启用主键，此时只启用主键，外键还是禁用状态。
select  OWNER,CONSTRAINT_NAME, TABLE_NAME,STATUS from user_constraints where table_name='EMP01';
检查约束状态

其它操作

alter table emp add constraint ck_emp_sal check (sal>1000 and sal is not null);
@?/rdbms/admin/utlexcpt.sql
alter table emp add constraint ck_t04_sal check (sal>=1000 and sal is not null) exceptions into exceptions;

删除约束

drop constraint:
alter table e drop constraint XXXXXXXXXX;
alter table d drop constraint PK_D_ID cascade;

管理视图
视图的优点

    限制对数据的访问（主要功能）
    简化复杂的查询
    数据的独立性
    不同的标准给访问数据的用户分组
    往往会降低性能

视图的分类―简单视图和复杂视图
特性 	简单视图 	复杂视图
表的数量 	1 	多个
包含函数 	no 	yes
包含组数据 	no 	yes
通过视图的dml操作 	yes 	不一定
管理视图的权限

    CREATE VIEW
    CREATE ANY VIEW

查看用户目前是否没有创建视图的权限

SQL> conn scott/tiger;
Connected.

SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
UNLIMITED TABLESPACE
CREATE TABLE
CREATE CLUSTER
CREATE SEQUENCE
CREATE PROCEDURE
CREATE TRIGGER
CREATE TYPE
CREATE OPERATOR
CREATE INDEXTYPE

10 rows selected.

授予用户创建视图的权限

SQL> conn / as sysdba
Connected.
SQL> grant CREATE VIEW to scott;

Grant succeeded.

SQL> conn scott/tiger;
Connected.
SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
UNLIMITED TABLESPACE
CREATE TABLE
CREATE CLUSTER
CREATE VIEW
CREATE SEQUENCE
CREATE PROCEDURE
CREATE TRIGGER
CREATE TYPE
CREATE OPERATOR
CREATE INDEXTYPE

11 rows selected.

创建视图

vu10为10部门的所有信息集和

create view vu10 as select * from emp where deptno=10;
create or replace view vu10 as select empno,ename,sal,deptno from emp where deptno=10;
create or replace view vu10 (employee_id,first_name,salary,department_id)
as select empno,ename,sal,deptno from emp where deptno=10;
create or replace view vu10 as select empno employee_id,ename,sal salary,deptno department_id from emp where deptno=10;

创建视图

create or replace force view vu30 as select empno,ename,sal,deptno from e01 where deptno=30;
select object_name,status from user_objects where object_name='VU30';
create or replace force view vu30 as select empno,ename,sal,deptno from e01 where deptno=30 with check option;
select text from user_views where view_name='VU30';

SQL> create or replace force view vu30 as select empno,ename,sal,deptno from e01 where deptno=30;
select object_name,status from user_objects where object_name='VU30';
Warning: View created with compilation errors.

SQL> create or replace force view vu30 as select empno,ename,sal,deptno from e01 where deptno=30 with check option;

Warning: View created with compilation errors.

SQL> select view_name ,text from user_views;

VIEW_NAME
------------------------------
TEXT
--------------------------------------------------------------------------------
BOOBOO01
select ename,sal,deptno from emp where deptno=10

VU30
select empno,ename,sal,deptno from e01 where deptno=30 with check option

删除视图

drop view vu30;

管理序列

    oracle和mysql不同，mysql中可以直接在列中声明自增长auto_increment

    自动生成的唯一序列号
    是可分享的对象
    通常用来创建主键值
    替代应用程序代码
    当缓冲在内存中时，加速访问序列的小略

数字产生器，只增不降，不可回退，为数字主键填充数据

create sequence seq_empno
start with 7935
increment by 1
minvalue 7935
maxvalue 9999
cache 50
nocycle;

SQL> create sequence seq_empno
  2  start with 7935                                                    
  3  increment by 1
  4  minvalue 7935
  5  maxvalue 9999
  6  cache 50
  7  nocycle;

Sequence created.

SQL> select * from user_sequences;

SEQUENCE_NAME			MIN_VALUE  MAX_VALUE INCREMENT_BY C O CACHE_SIZE
------------------------------ ---------- ---------- ------------ - - ----------
LAST_NUMBER
-----------
SEQ_EMPNO			     7935	9999		1 N N	      50
       7935

序列两个伪列

与序列相关的两个伪列，currval & nextval，崭新的序列没有初始化的序列没有currval只有nextval

    currval 当前值
    nextval 下一个值

select seq_empno.currval,seq_empno.nextval from dual;

序列的初始值不可以修改，其他属性都可以修改

alter sequence seq_empno increment by 5;
alter sequence seq_empno minvalue 7936;
alter sequence seq_empno maxvalue 8888;
alter sequence seq_empno cache 100;
alter sequence seq_empno cycle;

使用序列

insert into emp (empno) values (seq_empno.nextval);

删除序列

drop sequence seq_empno;

管理索引

    相当于目录，记录表中的关键字和rowid的对应关系，加速查找数据的速度。

何时创建索引

    一列包含有大范围值
    一列包含有大量空值
    多于一列经常在where字句或者联合条件下被一起使用
    表很大并且大部分的查询预期检索少于2%或%4的行数
    多不一定好

索引的数据字典

    user_indexes 数据字典视图包含索引的名字和唯一性
    user_ind_columns 视图包含索引名称，表名称和列名称
    index_stats 索引的详细信息

索引的操作
手工创建索引

create index i_emp_ename on emp (ename);

查看索引是否被使用

set autotrace traceonly explain
select * from emp where ename='SCOTT';
set autotrace off

基于函数的索引

create index i_emp_ename_f on emp (upper(ename));

删除索引

drop index I_EMP_NAME_F;

索引测试

--新建测试表e01
create table e01 as select * from emp;
--扩充数据
insert into e01 select * from e01;
--将该语句多执行几次
/
--修改empno的属性
alter table e01 modify (empno number);
--将empno的值改为rownum
update e01 set empno=rownum
--开启sqlplus中的时间记录器
set timing on
--查看当前该表的大小
SQL> select blocks/128 from user_segments where segment_name='E01';

BLOCKS/128
----------
	39
--39M
--看执行时间
SQL> select * from e01 where empno=1500;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM
---------- ---------- --------- ---------- --------- ---------- ----------
    DEPTNO
----------
      1500 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300
	30


Elapsed: 00:00:00.02

--看执行成本
set autot trace exp

SQL> set autot trace exp
SQL> select * from e01 where empno=1500;
Elapsed: 00:00:00.00

Execution Plan
----------------------------------------------------------
Plan hash value: 3036185917

--------------------------------------------------------------------------
| Id  | Operation	  | Name | Rows  | Bytes | Cost (%CPU)| Time	 |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |	 |    54 |  4698 |  1338   (1)| 00:00:17 |
|*  1 |  TABLE ACCESS FULL| E01  |    54 |  4698 |  1338   (1)| 00:00:17 |
--------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("EMPNO"=1500)

Note
-----
   - dynamic sampling used for this statement (level=2)

--查看e01表有4992个block块，每个block大小为8KB
SQL> select segment_name,blocks from user_segments where segment_name=upper('e01');

SEGMENT_NAME
--------------------------------------------------------------------------------
    BLOCKS
----------
E01
      4992
--当前为了找到empno为1500的行，会读取4992个block
--新建索引
SQL> create index i_e01_empno on e01 (empno);

Index created.
--重新查看相同的sql，对比执行成本的对比
SQL> set linesize 150
SQL> select * from e01 where empno=1500;
Elapsed: 00:00:00.00

Execution Plan
----------------------------------------------------------
Plan hash value: 2767643581

-------------------------------------------------------------------------------------------
| Id  | Operation		    | Name	  | Rows  | Bytes | Cost (%CPU)| Time	  |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT	    |		  |	1 |    87 |	2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| E01	  |	1 |    87 |	2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN	    | I_E01_EMPNO |	1 |	  |	2   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("EMPNO"=1500)

Note
-----
   - dynamic sampling used for this statement (level=2)
--可以看到执行成本从1338降低到2
--索引的详细信息
SQL> desc index_stats
 Name										     Null?    Type
 ----------------------------------------------------------------------------------- -------- --------------------------------------------------------
 HEIGHT 										      NUMBER
 BLOCKS 										      NUMBER
 NAME											      VARCHAR2(30)
 PARTITION_NAME 									      VARCHAR2(30)
 LF_ROWS										      NUMBER
 LF_BLKS										      NUMBER
 LF_ROWS_LEN										      NUMBER
 LF_BLK_LEN										      NUMBER
 BR_ROWS										      NUMBER
 BR_BLKS										      NUMBER
 BR_ROWS_LEN										      NUMBER
 BR_BLK_LEN										      NUMBER
 DEL_LF_ROWS										      NUMBER
 DEL_LF_ROWS_LEN									      NUMBER
 DISTINCT_KEYS										      NUMBER
 MOST_REPEATED_KEY									      NUMBER
 BTREE_SPACE										      NUMBER
 USED_SPACE										      NUMBER
 PCT_USED										      NUMBER
 ROWS_PER_KEY										      NUMBER
 BLKS_GETS_PER_ACCESS									      NUMBER
 PRE_ROWS										      NUMBER
 PRE_ROWS_LEN										      NUMBER
 OPT_CMPR_COUNT 									      NUMBER
 OPT_CMPR_PCTSAVE									      NUMBER

--打开scott用户的信息搜集
begin
dbms_stats.gather_schema_stats(ownname=>'scott',
estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE,
options=>'gather',
degree=>DBMS_STATS.AUTO_DEGREE,
method_opt=>'for all columns size repeat',
cascade=>TRUE);
END;
/

--查看表的情况
SQL> select num_rows,blocks from user_tab_statistics;

  NUM_ROWS     BLOCKS
---------- ----------
	 4	    5
	15	    5
	 0	    0
	 5	    5
	 0	    0
    860160	 4909

6 rows selected.

Elapsed: 00:00:00.06
SQL> select table_name,blocks from user_tables;

TABLE_NAME			   BLOCKS
------------------------------ ----------
E01				     4909
T01					0
SALGRADE				5
BONUS					0
EMP					5
DEPT					5

6 rows selected.
--查看索引情况
SQL> select index_name,blevel,num_rows from user_ind_statistics;

INDEX_NAME			   BLEVEL   NUM_ROWS
------------------------------ ---------- ----------
PK_DEPT 				0	   4
PK_EMP					0	  15
I_E01_EMPNO				2     860160


--分析索引结构有效性
--index_stats记录的时当前会话中最近一次的分析索引情况
select name,height,blocks,br_blks,br_rows,lf_blks,lf_rows from index_stats;

create index i_e01 on e01 (deptno);
select name,height,blocks,br_blks,br_rows,lf_blks,lf_rows from index_stats;
analyze index i_e01 validate structure;
select name,height,blocks,br_blks,br_rows,lf_blks,lf_rows from index_stats;

NAME				   HEIGHT     BLOCKS	BR_BLKS    BR_ROWS    LF_BLKS	 LF_ROWS
------------------------------ ---------- ---------- ---------- ---------- ---------- ----------
I_E01					3	1664	      5       1567	 1568	  802816

SQL> analyze index i_e01_empno validate structure;

Index analyzed.

Elapsed: 00:00:00.37
SQL> select name,height,blocks,br_blks,br_rows,lf_blks,lf_rows from index_stats;

NAME				   HEIGHT     BLOCKS	BR_BLKS    BR_ROWS    LF_BLKS	 LF_ROWS
------------------------------ ---------- ---------- ---------- ---------- ---------- ----------
I_E01_EMPNO				3	1920	      5       1791	 1792	  860160

index_stats表分析
属性 	说明
height 	索引的高度，层级从0开始
blocks 	索引在后台占用多少块
br_blks 	索引分支有多少块
br_rows 	索引分支有多少行
lf_blks 	叶子有多少块
lf_rows 	叶子有多少行

st=>start: 查找empno为450的行
i_br=>inputoutpu: 索引分支(1-480的行在xx叶子节点上)
i_lf=>inputoutput: 索引叶子(450的行对应的rowid为xxx)
data_b=>inputoutput: 数据块
e=>end

st->i_br->i_lf->data_b->e

    所有的数据都是放在叶子节点上
    分支记录的是“范围+地址”
    叶子记录的时“关键字+rowid的一个组合”
    rowid是记录数据的物理地址

通过rowid来查找数据是最快的

SQL> select rowid,ename,empno from e01 where rownum < 11;

ROWID		   ENAME	   EMPNO
------------------ ---------- ----------
AAAVo9AAEAAAAILAAA		       1
AAAVo9AAEAAAAILAAB SMITH	       2
AAAVo9AAEAAAAILAAC ALLEN	       3
AAAVo9AAEAAAAILAAD WARD 	       4
AAAVo9AAEAAAAILAAE JONES	       5
AAAVo9AAEAAAAILAAF MARTIN	       6
AAAVo9AAEAAAAILAAG BLAKE	       7
AAAVo9AAEAAAAILAAH CLARK	       8
AAAVo9AAEAAAAILAAI SCOTT	       9
AAAVo9AAEAAAAILAAJ KING 	      10

SQL> select rowid,empno,ename from e01 where rowid='AAAVo9AAEAAAAILAAI';

Execution Plan
----------------------------------------------------------
Plan hash value: 3699198527

-----------------------------------------------------------------------------------
| Id  | Operation		   | Name | Rows  | Bytes | Cost (%CPU)| Time	  |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT	   |	  |	1 |    22 |	1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY USER ROWID| E01  |	1 |    22 |	1   (0)| 00:00:01 |
-----------------------------------------------------------------------------------

SQL> select rowid,empno,ename from e01 where empno=9;

Execution Plan
----------------------------------------------------------
Plan hash value: 2767643581

-------------------------------------------------------------------------------------------
| Id  | Operation		    | Name	  | Rows  | Bytes | Cost (%CPU)| Time	  |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT	    |		  |	1 |    22 |	4   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| E01	  |	1 |    22 |	4   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN	    | I_E01_EMPNO |	1 |	  |	3   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("EMPNO"=9)

--可以看到通过rowid来查找数据的消耗是1

rowid的格式

rowid是64进制的

例如AAAVREAAEAAAACXAAI
对象id 	文件id 	块id 	row number
AAAVRE 	AAE 	AAAACX 	AAI
6位 	3位 	6位 	3位
object_id 	file_id 	block_id 	row number

    注意：在rowid中过的最后三位记录的row number是计算机记录的从0开始的，而我们在读表的时候使用的rownum是从1开始的。

64位换算

A  -   Z    a    -   z   0   -   9   +   /
0  -   25   26   -   51  52  -   61  62  63
VRE = 21*64*64+17*64+4 = 87108
2*64+23 = 151

--AAAVo9AAEAAAAILAAI 代表的含义
AAAVo9=21*64*64+40*64+61*1=88637
AAE=4
AAAAIL=8*64+11=523
AAI=8

对象id为88637
文件id为4
块id为523
rownum为8

--通过rowid来手动读取数据
conn / as sysdba
alter system dump datafile 4 block 523;
show parameter background;

SQL> show parameter background

NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
background_core_dump		     string	 partial
background_dump_dest		     string	 /u01/app/oracle/diag/rdbms/orc
						 l/orcl/trace
[oracle@oracle0 ~]$ cd /u01/app/oracle/diag/rdbms/orcl/orcl/trace
[oracle@oracle0 trace]$ ll
total 3280
-rw-r----- 1 oracle oinstall   87570 Oct 12 13:20 alert_orcl.log
drwxr-xr-x 2 oracle oinstall    4096 Oct 12 13:11 cdmp_20171012131154
-rw-r----- 1 oracle oinstall    3105 Oct  9 12:45 orcl_ckpt_2709.trc
-rw-r----- 1 oracle oinstall      98 Oct  9 12:45 orcl_ckpt_2709.trm
-rw-r----- 1 oracle oinstall    4431 Oct 12 13:32 orcl_ckpt_2711.trc
[oracle@oracle0 trace]$ for i in `ls`;do grep -l data_block $i ;done
orcl_diag_2717_20171012131154.trc
orcl_ora_3395.trc

Trace file /u01/app/oracle/diag/rdbms/orcl/orcl/trace/orcl_ora_3395.trc
Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
ORACLE_HOME = /u01/app/oracle/product/11.2.0/db_1
System name:    Linux
Node name:      oracle0.example.com
Release:        2.6.18-398.el5
Version:        #1 SMP Tue Aug 12 06:26:17 EDT 2014
Machine:        x86_64
Instance name: orcl
Redo thread mounted by this instance: 1
Oracle process number: 19
Unix process pid: 3395, image: oracle@oracle0.example.com (TNS V1-V3)


*** 2017-10-12 14:53:12.908
*** SESSION ID:(138.11) 2017-10-12 14:53:12.908
*** CLIENT ID:() 2017-10-12 14:53:12.908
*** SERVICE NAME:(SYS$USERS) 2017-10-12 14:53:12.908
*** MODULE NAME:(sqlplus@oracle0.example.com (TNS V1-V3)) 2017-10-12 14:53:12.908
*** ACTION NAME:() 2017-10-12 14:53:12.908
...此处省略
tab 0, row 8, @0xb6e
tl: 39 fb: --H-FL-- lb: 0x2  cc: 8
col  0: [ 2]  c1 0a
col  1: [ 5]  53 43 4f 54 54
col  2: [ 7]  41 4e 41 4c 59 53 54
col  3: [ 3]  c2 4c 43
col  4: [ 7]  77 bb 04 13 01 01 01
col  5: [ 2]  c2 1f
col  6: *NULL*
col  7: [ 2]  c1 15
--找到rownum=8的行，找到ename列的值为“53 43 4f 54 54”16进制
select chr(to_number('53','xx'))||chr(to_number('43','xx'))||chr(to_number('4f','xx'))||chr(to_number('54','xx'))||chr(to_number('54','xx')) from dual;

SQL> select chr(to_number('53','xx'))||chr(to_number('43','xx'))||chr(to_number('4f','xx'))||chr(to_number('54','xx'))||chr(to_number('54','xx')) from dual;

CHR(T
-----
SCOTT

oracle中可以通过chr(to_number('43','xx'))将16进制转字符串
管理同义词

    对象的别名

创建私有同义词

create synonym e01 for scott.e01;

创建公有同义词

create public synonym e01 for scott.e01;

删除同义词

drop synonym e01;


SQL语句-DCL管理用户

权限的分类

权限分为：

    系统权限：获取访问数据库的权限 （典型的DBA权限；用户系统权限）
    对象权限：操作数据库对象的内容

    个人理解：系统权限包括了ddl和dcl语句;对象权限包括了alter和dql和dml

系统权限

    超过100个权限可用
    数据库管理员拥有高级别的系统权限用于进行下列任务：创建、删除用户；删除表；备份表

典型的DBA权限
系统权限 	操作认证
create user 	创建其他数据库用户（需要dba角色）
drop user 	删除一个用户
drop any table 	删除任何模式下的表
backup any table 	使用导出工具备份任何模式中的表
select any table 	在模式中查询表，视图或者快照
create any table 	在任何模式下可以创建表

    模式是对象的集和，例如表，视图，子查询。

典型用户权限
系统权限 	操作认证
create session 	连接到数据库
create table 	在用户的模式中创建表
create sequence 	在用户的模式中创建序列
create view 	在用户的模式中创建视图
create procedure 	在用户的模式中创建一个存储过程，函数或者包
对象权限

授予对象权限

不同的对象权限对不同类型的模式对象是可用的。一个用户自动拥有包含在用户模式里面模式对象的对象权限。

    我的理解：拥有该表用户默认就拥有了对该表的所有对象权限（例如DQL\DML和alter），表可以该为其他对象例如视图、序列、过程。

一个用户可以将自己拥有的模式对象上面的所有对象权限授予任何其他的用户和角色。如果授予时使用了WITH GRANT OPTION，那么受让人可以将对象权限进一步授予其他的用户；否则受让人只可以使用权限，但是不可以将它授予其他人。

WITH GRANT OPTION

授予的特权可以将特权传递给其他的用户和角色。

PUBLIC

授权所有用户访问这张表

    我的理解：

    我的表可以给别人（B）使用吗？可以的。
    别人（B）可以把我的表再给C使用吗？ 可以的。
    我想把我的表给所有人使用可以吗？ 可以的。

对象权限 	表 	视图 	序列 	过程
alter 	* 		* 	
select 	* 	* 	* 	
update 	* 	* 		
delete 	* 	* 		
insert 	* 			
execute 				*
index 	* 			
references 	* 	* 		
角色
什么是角色？

角色是命名的组，包含相关的权限可以授予用户。这个方法可以使撤销和维护权限变得简单。一个用户可以拥有几个角色，几个用户可以分配相同的角色。角色通常为数据库的应用程序创建。
创建和分配角色
步骤

    DBA必须创建角色
    DBA可以分配权利
    DBA给用户授与角色

语法

create role x_role;
grant create table , create view to x_role;
grant x_role to batman,superman;

实践

create role r1;
grant create session,create table to r1;

create role r2;
grant create view to r2;
grant delete on scott.emp to r2;

create role r3;
grant create procedure to r3;
grant update (sal) on scott.emp to r3;

grant r3 to r1;

create user tom identified by tom;
grant r1,r2 to tom;

grant create sequence to tom;
grant select on scott.emp to tom;
grant insert on scott.emp to tom;
grant update (comm) on scott.emp to tom;

数据字典-与角色和权限相关
数据字典视图 	描述
role_sys_privs 	角色被授予的系统权限
role_tab_privs 	角色被授予的对象权限
user_role_privs 	用户被授予的角色权限
user_tab_privs 	用户对象权限
user_tab_privs_made 	用户的对象被授予的对象权限
user_tab_privs_recd 	用户被授予的对象权限
user_col_privs 	用户对象对权限
user_col_privs_made 	用户对象的列被授予的对象权限
user_col_privs_recd 	用户指定的列被授予的对象权限
user_sys_privs 	用户被授予的系统权限
dba_sys_privs 	用户被授予的系统权限
dba_tab_privs 	用户被授予的对象权限
dba_col_privs 	用户被授予的列级别的对象权限
dba_role_privs 	用户被授予的角色权限

    我的理解： user_tab_privs | 用户对象权限 | 我给别人的权限和别人给我的权限，对象级别| user_tab_privs_made | 用户的对象被授予的对象权限 | 我给别人的权限，对象级别| user_tab_privs_recd | 用户被授予的对象权限 | 别人给我的权限，对象级别|

实践1-查看用户的权限

背景：scott用户给ops$boobo 授权了emp表的select权限

    使用ops$boobo 用户登陆，查看拥有的系统权限

SQL> select * from user_sys_privs;

USERNAME		       PRIVILEGE				ADM
------------------------------ ---------------------------------------- ---
OPS$BOOBOO		       CREATE SESSION				NO

从返回结果可知，用户拥有的系统权限为CREATE SESSION。

    使用ops$boobo 用户登陆，查看对象权限

SQL> set linesize 500
SQL> select * from user_tab_privs;

GRANTEE 		       OWNER			      TABLE_NAME		     GRANTOR			    PRIVILEGE				     GRA HIE
------------------------------ ------------------------------ ------------------------------ ------------------------------ ---------------------------------------- --- ---
OPS$BOOBOO		       SCOTT			      EMP			     SCOTT			    SELECT				     YES NO

SQL> select * from user_tab_privs_recd;

OWNER			       TABLE_NAME		      GRANTOR			     PRIVILEGE				      GRA HIE
------------------------------ ------------------------------ ------------------------------ ---------------------------------------- --- ---
SCOTT			       EMP			      SCOTT			     SELECT				      YES NO

SQL> select * from user_tab_privs_made;

no rows selected

    SCOTT用户 给了 OPS$BOOBOO 用户 SCOTT.EMP 的 SELECT 权限；
    OPS$BOOBOO 用户 没有给 其他用户 授权的对象；

    使用 scott 用户登陆，查看对象权限

SQL> select * from user_tab_privs;

GRANTEE 		       OWNER			      TABLE_NAME		     GRANTOR			    PRIVILEGE				     GRA HIE
------------------------------ ------------------------------ ------------------------------ ------------------------------ ---------------------------------------- --- ---
OPS$BOOBOO		       SCOTT			      EMP			     SCOTT			    SELECT				     YES NO

SQL> select * from user_tab_privs_recd;

no rows selected

SQL> select * from user_tab_privs_made;

GRANTEE 		       TABLE_NAME		      GRANTOR			     PRIVILEGE				      GRA HIE
------------------------------ ------------------------------ ------------------------------ ---------------------------------------- --- ---
OPS$BOOBOO		       EMP			      SCOTT			     SELECT				      YES NO

    其他用户 没有给 SCOTT 用户 授权的对象；
    SCOTT 用户 授予了 OPS$BOOBOO 用户 SCOTT.EMP 的 SELECT 权限；

级联授权

dba --> user A --> user B
系统权限级联授权：with admin option 权限回收无级联

grant CREATE SEQUENCE to tom with admin option;

对象权限级联授权：with grant option 权限回收有级联

grant insert on scott.e01 to tom with grant option;

实践1-系统用户只能用with admin option

SQL> conn / as sysdba   
Connected.

级联授权

SQL> grant create table to ops$booboo with admin option;

ops$booboo用户授权给ops$oracle用户create table的权限

SQL> grant create table to ops$oracle;

sysdba回收ops$booboo用户的create table权限

SQL> conn / as sysdba
Connected.
SQL> revoke create table from ops$booboo;

测试发现ops$booboo用户的create table权限被回收了，而ops$oracle用户create table的权限没有被回收
实践2-一般用户只能使用with grant option

一般用户只能使用with grant option

SQL> grant select on emp to ops$booboo with admin option;
grant select on emp to ops$booboo with admin option
                                       *
ERROR at line 1:
ORA-00993: missing GRANT keyword


SQL> grant select on emp to ops$booboo with grant option;

Grant succeeded.

OPS$BOOBOO再授权给其他用户

SQL> grant select on scott.emp to ops$oracle ;

Grant succeeded.

SQL> show user;
USER is "OPS$BOOBOO"
SQL> set linesize 150
SQL> select * from scott.emp where rownum < 3;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30
--OPS$ORACLE用户
SQL> show user;
USER is "OPS$ORACLE"

SQL> set linesize 150;
SQL> select * from scott.emp where rownum < 3;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30

scott用户回收对OPS$BOOBOO的授权后，ops$oracle也会失去select权限

SQL> revoke select on emp from ops$booboo;

Revoke succeeded.

用户权限总结
功能 	命令
创建用户的基本命令 	create user smith identified by smith;
授予权限 	grant create session to smith;
连接到指定用户下 	conn smith/smith
查看当前用户是谁 	show user
查看当前版本下所有的系统权限 	select distinct privilege from dba_sys_privs;
查看与table有关的权限 	select distinct privilege from dba_sys_privs where privilege like '%TABLE%';
回收权限 	revoke CREATE ANY TABLE from SMITH;
查看用户拥有的权限 	select * from session_privs;
使用角色管理权限 	create role r_clerk;grant create session,create table,create synonym to r_clerk;grant r_clerk to smith;
角色的嵌套 	create user jones identified by jones password expire;create role r_manager;grant r_clerk,create view to r_manager;grant r_manager to jones;
使用sql语句修改用户口令 	alter user jones identified by oracle;
使用sql语句解锁用户 	alter user scott identified by tiger account unlock;
使用sqlplus命令修改口令 	password
对象权限 	SQL> grant select on scott.e01 to smith;SQL> grant update (comm) on scott.e01 to smith;SQL> grant delete on scott.e01 to smith;SQL> grant insert on scott.e01 to smith;
查看用户被授予的系统权限 	SQL> select privilege from dba_sys_privs where GRANTEE='TOM';
查看用户被授予的对象权限 	col GRANTEE for a15；col PRIVILEGE for a20；col owner for a15；SQL> SELECT GRANTEE,PRIVILEGE,OWNER,TABLE_NAME FROM DBA_TAB_PRIVS WHERE GRANTEE='TOM'；
查看用户被授予的列级别的对象权限 	SQL> SELECT OWNER,TABLE_NAME,COLUMN_NAME,PRIVILEGE FROM DBA_COL_PRIVS where GRANTEE='TOM';
用户被授予的角色 	SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE='TOM';
角色被授予的角色 	SELECT * FROM ROLE_ROLE_PRIVS WHERE ROLE='R1';
角色被授予的系统权限 	select * from ROLE_SYS_PRIVS WHERE ROLE='R1';
角色被授予的对象权限 	select * from ROLE_TAB_PRIVS WHERE ROLE='R1';

--sysdba创建一个用户blake
SQL> create user blake identified by blake;

User created.
--该用户什么都做不了
SQL> conn blake/blake;
ERROR:
ORA-01045: user BLAKE lacks CREATE SESSION privilege; logon denied


Warning: You are no longer connected to ORACLE.
--MySQL创建用户就会默认存在一个usage的权限允许该用户连接上数据库服务器

--Oracle需要给用户授予create session的权限才能允许连接
SQL> conn / as sysdba
Connected.
SQL> grant create session to blake;

Grant succeeded.

SQL> conn blake/blake;
Connected.
SQL> show user;
USER is "BLAKE"

--用户的命名规则
--操作系统审核的用户：安全机制在系统级别，则前缀为ops$，后缀为当前登陆到服务器的操作系统用户名
--os_authent_prefix 变量的值为 ops$
SQL> conn / as sysdba
Connected.

SQL> show parameter os

NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
db_lost_write_protect		     string	 NONE
diagnostic_dest 		     string	 /u01/app/oracle
optimizer_index_cost_adj	     integer	 100
os_authent_prefix		     string	 ops$
os_roles			     boolean	 FALSE
remote_os_authent		     boolean	 FALSE
remote_os_roles 		     boolean	 FALSE
timed_os_statistics		     integer	 0

--后缀为当前登陆到服务器的操作系统用户名
SQL> select distinct osuser from v$session;

OSUSER
------------------------------
oracle

--如何创建操作系统审核的用户
SQL> create user ops$oracle identified by oracle;

User created.

SQL> grant create session to ops$oracle;

Grant succeeded.

SQL> conn /
Connected.
SQL> show user;
USER is "OPS$ORACLE"

--若目前是booboo用户登陆的服务器如何创建一个对应的操作系统审核用户
--booboo的所属组为oinstall，附加组为dba

[root@oracle0 ~]# id booboo
uid=501(booboo) gid=501(oinstall) groups=501(oinstall),500(dba)
[root@oracle0 ~]# su - booboo
[booboo@oracle0 ~]$ sqlplus / as sysdba

SQL*Plus: Release 11.2.0.4.0 Production on Fri Oct 20 17:20:09 2017

Copyright (c) 1982, 2013, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> select distinct osuser from v$session ;

OSUSER
------------------------------
booboo
oracle

SQL> show parameter os;

NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
db_lost_write_protect		     string	 NONE
diagnostic_dest 		     string	 /u01/app/oracle
optimizer_index_cost_adj	     integer	 100
os_authent_prefix		     string	 ops$
os_roles			     boolean	 FALSE
remote_os_authent		     boolean	 FALSE
remote_os_roles 		     boolean	 FALSE
timed_os_statistics		     integer	 0
SQL> grant create session to ops$booboo identified by booboo;

Grant succeeded.

SQL> conn /
Connected.
SQL> show user
USER is "OPS$BOOBOO"

--查看自己的权限
SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION

--查看sysdba的权限
SQL> conn / as sysdba
SQL> select * from session_privs;

--授予多个系统权限给一个用户
SQL> grant create table,create sequence to ops$booboo;

Grant succeeded.

SQL> conn /
Connected.
SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
CREATE TABLE
CREATE SEQUENCE
--注意此处的create权限包含了对对象的创建、修改、删除操作

SQL> conn /
Connected.

SQL> create table t1 (id int);

Table created.
SQL> insert into t1 values (1);
insert into t1 values (1)
            *
ERROR at line 1:
ORA-01950: no privileges on tablespace 'USERS'

SQL> alter table t1 add (name int);

Table altered.

SQL> desc t1;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 ID						    NUMBER(38)
 NAME						    NUMBER(38)

SQL> drop table t1 purge;

Table dropped.

--回收权限
SQL> conn / as sysdba   
Connected.
SQL> revoke create table ,create sequence from ops$booboo ;

--级联授权
SQL> grant create table to ops$booboo with admin option;

SQL> conn /
Connected.
SQL> show user;
USER is "OPS$BOOBOO"

Grant succeeded.

SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
CREATE TABLE

SQL> grant create table to tom ;

Grant succeeded.

SQL> grant create table to ops$oracle;

Grant succeeded.

SQL语句-DQL语句的使用

集合运算
union会压缩重复值

select * from e01
union
select * from emp;

union all没有去重效果

select * from e01
union all
select * from emp;

intersect求交集

select * from e01
intersect
select * from emp;

minus求集合A与集合B不同的地方

select * from e01
minus
select * from emp;
--有顺序之别
select * from emp
minus
select * from e01;

练习

select * from e01
union all
select dept.*,null,null,null,null,null from dept;

SQL> select * from e01 union all select dept.*,null,null,null,null,null from dept;

     EMPNO ENAME	  JOB		       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- -------------- ------------- ---------- --------- ---------- ---------- ----------
      7369 SMITH	  CLERK 	      7902 17-DEC-80	    800 		   20
      7499 ALLEN	  SALESMAN	      7698 20-FEB-81	   1600        300	   30
	10 ACCOUNTING	  NEW YORK
	20 RESEARCH	  DALLAS
	30 SALES	  CHICAGO
	40 OPERATIONS	  BOSTON

扩展的时间
时间戳timestamp

SQL> create table t01 (x int,y timestamp);
SQL> insert into t01 values (1,current_timestamp);
SQL> alter table t01 modify (y timestamp(9));

练习

SQL> select * from tab;

TNAME			       TABTYPE	CLUSTERID
------------------------------ ------- ----------
BONUS			       TABLE
DEPT			       TABLE
EMP			       TABLE
SALGRADE		       TABLE

SQL> create table t01 (id int,hiredate timestamp);

Table created.

SQL> insert into t01 values (1,current_date);

1 row created.

SQL> select * from t01;

	ID HIREDATE
---------- ---------------------------------------------------------------------------
	 1 26-OCT-17 07.50.04.000000 PM

SQL> drop table t01 purge;  

Table dropped.

SQL> create table t01 (id int,hiredate timestamp(9));

Table created.

SQL> insert into t01 values (1,current_date);

1 row created.

SQL> select * from t01;

	ID HIREDATE
---------- ---------------------------------------------------------------------------
	 1 26-OCT-17 07.51.16.000000000 PM

全球化时间戳timestamp with time zone

create table t02 (x int,y timestamp with time zone);

练习

SQL> create table t02 (id int,hiredate timestamp with time zone);

Table created.

SQL> insert into t02 values (1,current_date);

1 row created.

SQL> select * from t02;

	ID HIREDATE
---------- ---------------------------------------------------------------------------
	 1 26-OCT-17 07.52.55.000000 PM +08:00

SQL> select * from t01;

	ID HIREDATE
---------- ---------------------------------------------------------------------------
	 1 26-OCT-17 07.51.16.000000000 PM

本地时间戳timestamp with local time zone

SQL> create table t03 (x int,y timestamp with local time zone);

练习

SQL> create table t03 (id int,hiredate timestamp with local time zone);

Table created.

SQL> insert into t03 values (1,current_date);

1 row created.

SQL> select * from t03;

	ID HIREDATE
---------- ---------------------------------------------------------------------------
	 1 26-OCT-17 07.55.00.000000 PM

当前会话的时区sessiontimezone

SQL> select sessiontimezone from dual;

SESSIONTIMEZONE
---------------------------------------------------------------------------
+08:00

实践1-练习修改时区

SQL> alter session set time_zone='-08:00';

SQL> select * from t01 union all select * from t02 union select * from t03;

	ID HIREDATE
---------- ---------------------------------------------------------------------------
	 1 26-OCT-17 07.52.55.000000000 PM +08:00
	 1 26-OCT-17 03.55.00.000000000 AM -08:00
	 1 26-OCT-17 07.51.16.000000000 PM -08:00

SQL> alter session set time_zone='+8:00';

Session altered.

SQL> select * from t01 union all select * from t02 union select * from t03;

	ID HIREDATE
---------- ---------------------------------------------------------------------------
	 1 26-OCT-17 07.51.16.000000000 PM +08:00
	 1 26-OCT-17 07.52.55.000000000 PM +08:00
	 1 26-OCT-17 07.55.00.000000000 PM +08:00

当前数据库时区

SQL> select dbtimezone from dual;

DBTIME
------
+00:00

时间函数

    sysdate 返回操作系统时间一样
    current_date 受当前会话时区影响
    current_timestamp 不受时区影响
    localtimestamp 受当前会话时区影响
    extract()萃取函数
    from_tz()函数实现与时间戳的转换
    tz_offset()函数将时区别名转换为以UTC为标准的OFFSET
    to_timestamp() 转化为时间戳
    to_timestamp_tz(） 返回带时区的时间戳
    to_yminterval() 返回时间段（年月）
    to_dsinterval() 返回时间段（天小时分钟秒）

练习

SQL> select sysdate,current_date,current_timestamp,localtimestamp from dual;

SYSDATE   CURRENT_D CURRENT_TIMESTAMP							LOCALTIMESTAMP
--------- --------- --------------------------------------------------------------------------- ---------------------------------------------------------------------------
26-OCT-17 26-OCT-17 26-OCT-17 08.13.25.606912 PM +08:00 				26-OCT-17 08.13.25.606912 PM

SQL> alter session set time_zone='+5:00';

Session altered.

SQL> select sysdate,current_date,current_timestamp,localtimestamp from dual;

SYSDATE   CURRENT_D CURRENT_TIMESTAMP								LOCALTIMESTAMP
--------- --------- --------------------------------------------------------------------------- ---------------------------------------------------------------------------
26-OCT-17 26-OCT-17 26-OCT-17 05.14.45.191839 PM +05:00 					26-OCT-17 05.14.45.191839 PM

实践1

SQL> select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(current_date,'yyyy-mm-dd hh24:mi:ss') from dual;

TO_CHAR(SYSDATE,YY TO_CHAR(CURRENT_DAT
------------------- -------------------
2015-12-22 13:41:00 2015-12-22 13:41:00

SQL> alter session set time_zone='-8:00';

SQL> select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(current_date,'yyyy-mm-dd hh24:mi:ss') from dual;

TO_CHAR(SYSDATE,YY TO_CHAR(CURRENT_DAT
------------------- -------------------
2015-12-22 13:43:38 2015-12-21 21:43:38

select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(current_date,'yyyy-mm-dd hh24:mi:ss'),current_timestamp from dual;

TO_CHAR(SYSDATE,YY TO_CHAR(CURRENT_DAT CURRENT_TIMESTAMP
------------------- ------------------- ---------------------------------------------------------------------------
2015-12-22 13:46:26 2015-12-21 21:46:26 21-DEC-15 09.46.26.500401 PM -08:00

select
to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),
to_char(current_date,'yyyy-mm-dd hh24:mi:ss'),
current_timestamp,
localtimestamp
from dual;

SQL> select dbtimezone,sessiontimezone from dual;

实践2

SQL> select extract(month from sysdate) from dual;
SQL> select to_number(to_char(sysdate,'mm')) from dual;

TO_NUMBER(TO_CHAR(SYSDATE,'MM'))
--------------------------------
			      10


SQL> select extract(year from sysdate) from dual;
SQL> select to_number(to_char(sysdate,'yy')) from dual;

TO_NUMBER(TO_CHAR(SYSDATE,'YY'))
--------------------------------
			      17

实践3

SQL> select from_tz(timestamp '2015-12-22 13:58:00','+08:00') from dual;
SQL> select from_tz(timestamp '2015-12-22 13:58:00','Australia/North') from dual;
SQL> select tz_offset('Australia/North') from dual

--查看时区
SQL> select * from v$timezone_names;

SQL> select to_timestamp('2016-09-19 15:31:00','yyyy-mm-dd hh24:mi:ss') from dual;
TO_TIMESTAMP('2016-09-1915:31:00','YYYY-MM-DDHH24:MI:SS')
---------------------------------------------------------------------------
19-SEP-16 03.31.00.000000000 PM

SQL> select to_timestamp_tz('2016-09-19 15:31:00 +03:00','yyyy-mm-dd hh24:mi:ss tzh:tzm') from dual;
TO_TIMESTAMP_TZ('2016-09-1915:31:00+03:00','YYYY-MM-DDHH24:MI:SSTZH:TZM')
---------------------------------------------------------------------------
19-SEP-16 03.31.00.000000000 PM +03:00


--查看数据库的时区描述
SQL> select * from v$timezone_names;
SQL> select tz_offset('US/Samoa') from dual;
TZ_OFFS
-------
-11:00

select sysdate+to_yminterval('02-06') from dual;
SYSDATE+T
---------
26-APR-20


select sysdate,sysdate+to_yminterval('01-10')+to_dsinterval('05 18:25:17') from dual;
SYSDATE   SYSDATE+T
--------- ---------
26-OCT-17 01-SEP-19

select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),
to_char(sysdate+to_dsinterval('5 02:10:18'),'yyyy-mm-dd hh24:mi:ss')
from dual;
TO_CHAR(SYSDATE,YY TO_CHAR(SYSDATE+TO_
------------------- -------------------
2017-10-26 20:34:04 2017-10-31 22:44:22

增强的Group By
roll()n+1种聚集运算的结果

roll(a,b,c) --> n+1种聚集运算的结果

group by a
group by a,b
group by a,b,c
total

cube()2的n次方种聚集运算的结果

cube(a,b,c) --> 2的n次方种聚集运算的结果
group by a
group by b
group by c
group by a,b
group by a,c
group by b,c
group by a,b,c
total

实践

select deptno,job,sum(sal),grouping(deptno),grouping(job)
from emp group by rollup(deptno,job);

col deptno for a15
select decode(GROUPING(DEPTNO)||GROUPING(JOB),'01','subtotal '||deptno,'11','total ',deptno) deptno,job,sum(sal) from emp group by rollup(deptno,job);

select deptno,job,mgr,sum(sal)
from emp group by grouping sets ((deptno,job),(job,mgr));

练习结果

mysql rollup帮助

--mysql中对应的方法为 group by deptno, job with rollup
SQL> select deptno,job,sum(sal) from emp group by rollup(deptno, job);

    DEPTNO JOB			SUM(SAL)
---------- ------------------ ----------
	10 CLERK		    1300
	10 MANAGER		    2450
	10 PRESIDENT		    5000
	10			    8750
	20 CLERK		    1900
	20 ANALYST		    6000
	20 MANAGER		    2975
	20			   10875
	30 CLERK		     950
	30 MANAGER		    2850
	30 SALESMAN		    5600

    DEPTNO JOB			SUM(SAL)
---------- ------------------ ----------
	30			    9400
				   29025

13 rows selected.

--grouping()函数获取该行记录哪些列参与了group by，0代表参与；1代表没有参与
SQL> select deptno, job, sum(sal), grouping(deptno), grouping(job) from emp group by rollup(deptno, job);

    DEPTNO JOB			SUM(SAL) GROUPING(DEPTNO) GROUPING(JOB)
---------- ------------------ ---------- ---------------- -------------
	10 CLERK		    1300		0	      0
	10 MANAGER		    2450		0	      0
	10 PRESIDENT		    5000		0	      0
	10			    8750		0	      1
	20 CLERK		    1900		0	      0
	20 ANALYST		    6000		0	      0
	20 MANAGER		    2975		0	      0
	20			   10875		0	      1
	30 CLERK		     950		0	      0
	30 MANAGER		    2850		0	      0
	30 SALESMAN		    5600		0	      0
	30			    9400		0	      1
				   29025		1	      1

--获取每个部门的小计和总计
SQL> select deptno, sal from (select deptno, job, sum(sal) sal, grouping(deptno) g_d, grouping(job) g_j from emp group by rollup(deptno, job)) t1
  2  where g_j = 1 or g_d =1 ;

    DEPTNO	  SAL
---------- ----------
	10	 8750
	20	10875
	30	 9400
		29025

高级子查询
with as ()

哪些部门的总工资高于所有部门的平均总工资

with
dept_costs as (
select d.department_name, sum(e.salary) as dept_total
from employees e, departments d
where e.department_id = d.department_id
group by d.department_name
),
avg_cost as (
select sum(dept_total)/count(*) as dept_avg
from dept_costs
)
select * from  dept_costs
where dept_total > (select dept_avg from avg_cost)
order by department_name;

分级查询（爬树）

select level,lpad(ename,length(ename)+level*2-2,' ') ename
from emp start with empno=7839 connect by prior empno=mgr;

修改爬树的起点： start with

select level,lpad(ename,length(ename)+level*2-2,' ') ename
from emp start with ename='JONES' connect by prior empno=mgr;

修改爬树的方向：connect by prior 父键在前向下爬，子键在前向上爬

select level,lpad(ename,length(ename)+level*2-2,' ') ename
from emp start with ename='JONES' connect by prior mgr=empno;

剪枝： 剪枝条件出现在where子句,剪一个节点

select level,lpad(ename,length(ename)+level*2-2,' ') ename
from emp
where ename<>'BLAKE'
start with empno=7839 connect by prior empno=mgr;

剪枝条件出现在connect by prior子句，剪一个派系

select level,lpad(ename,length(ename)+level*2-2,' ') ename
from emp
start with empno=7839 connect by prior empno=mgr and ename<>'BLAKE';

insert扩展
insert all

drop table e01 purge;
drop table e02 purge;
create table e01 as select empno,ename,sal from emp where 1=0;
create table e02 as select ename,sal,comm,deptno from emp where 1=0;

insert all
into e01 values (empno,ename,sal)
into e02 values (ename,sal,comm,deptno)
select empno,ename,sal,comm,deptno from emp;

带条件的insert all

insert all
when deptno=10 then
into e01 values (empno,ename,sal)
when sal>2000 then
into e02 values (ename,sal,comm,deptno)
select empno,ename,sal,comm,deptno from emp;

带条件的insert first

insert first
when deptno=10 then
into e01 values (empno,ename,sal)
when sal>2000 then
into e02 values (ename,sal,comm,deptno)
select empno,ename,sal,comm,deptno from emp;

旋转插入

创建一张表：销售元数据

create table sales_source_data (employee_id number,week_id number,sales_mon number,sales_tue number,sales_wed number,sales_thur number,sales_fri number);

insert into sales_source_data values (178,1,3500,2200,4300,1500,5000);
insert into sales_source_data values (179,2,2800,3300,1000,800,4400);

创建一张表：销售信息表

create table sales_info (employee_id number,week number,sales number);

insert into sales_info select * from
(select employee_id,week_id week,sum(decode(WEEK_ID,1,SALES_MON,2,SALES_mon)) sales
from sales_source_data group by employee_id,week_id
union all
select employee_id,week_id week,sum(decode(WEEK_ID,1,SALES_tue,2,SALES_tue)) sales
from sales_source_data group by employee_id,week_id
union all
select employee_id,week_id week,sum(decode(WEEK_ID,1,SALES_wed,2,SALES_wed)) sales
from sales_source_data group by employee_id,week_id
union all
select employee_id,week_id week,sum(decode(WEEK_ID,1,SALES_thur,2,SALES_thur)) sales
from sales_source_data group by employee_id,week_id
union all
select employee_id,week_id week,sum(decode(WEEK_ID,1,SALES_fri,2,SALES_fri)) sales
from sales_source_data group by employee_id,week_id);

insert all
into sales_info values (employee_id,week_id,SALES_mon)
into sales_info values (employee_id,week_id,SALES_tue)
into sales_info values (employee_id,week_id,SALES_wed)
into sales_info values (employee_id,week_id,SALES_thur)
into sales_info values (employee_id,week_id,SALES_fri)
select * from sales_source_data;

create table sales_info (employee_id number,week_id number,day_id varchar2(4),sales number);

insert all
into sales_info values (employee_id,week_id,'MON',SALES_mon)
into sales_info values (employee_id,week_id,'TUE',SALES_tue)
into sales_info values (employee_id,week_id,'WED',SALES_wed)
into sales_info values (employee_id,week_id,'THUR',SALES_thur)
into sales_info values (employee_id,week_id,'FRI',SALES_fri)
select * from sales_source_data;

外部表

准备文本文件

vi /home/oracle/1.txt
7369,SMITH,CLERK,7902,1980/12/17:00:00:00,852,,20
7499,ALLEN,SALESMAN,7698,1981/02/20:00:00:00,1673,300,30
7521,WARD,SALESMAN,7698,1981/02/22:00:00:00,1251,500,30
7566,JONES,MANAGER,7839,1981/04/02:00:00:00,2980,,20
7654,MARTIN,SALESMAN,7698,1981/09/28:00:00:00,1290,1400,30
7698,BLAKE,MANAGER,7839,1981/05/01:00:00:00,2900,,30

vi /home/oracle/2.txt
7782,CLARK,MANAGER,7839,1981/06/09:00:00:00,2450,,10
7839,KING,PRESIDENT,,1981/11/17:00:00:00,5000,,10
7844,TURNER,SALESMAN,7698,1981/09/08:00:00:00,1500,0,30

创建逻辑目录并授权

conn / as sysdba
CREATE DIRECTORY mydir AS '/home/oracle';
GRANT READ,WRITE ON DIRECTORY mydir TO SCOTT;

创建外部表

conn scott/tiger
CREATE TABLE scott.refemp
(emp_id number(4),
ename varchar2(12),
job varchar2(12) ,
mgr_id number(4) ,
hiredate date,
salary number(8),
comm number(8),
dept_id number(2))
ORGANIZATION EXTERNAL
(TYPE ORACLE_LOADER
DEFAULT DIRECTORY mydir
ACCESS PARAMETERS(RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ','
(emp_id char,
ename char,
job char,
mgr_id char,
hiredate char date_format date mask "yyyy/mm/dd:hh24:mi:ss",
salary char,
comm char,
dept_id char))
LOCATION('1.txt','2.txt'));

exists

select * from e01 a where exists (select 1 from e01 where a.rowid!=e01.rowid and e01.empno=a.empno);

select * from e01 a where rowid in (select max(rowid) from e01 where e01.empno=a.empno);

delete e01 where rowid not in (select max(rowid) from e01 group by empno,ename,job,hiredate,job,sal,comm,deptno);

找到重复的行

select * from e01 a where exists (select 1 from e01 e where a.rowid!=e.rowid and e.empno=a.empno);

查找重复行的rowid 方法1：

select rowid from e01 a where a.rowid!= (select max(rowid) from e01 e where e.empno=a.empno and e.ename=a.ename);

查找重复行的rowid 方法2：

select rowid from e01 a where rowid not in (select max(rowid) from e01 group by empno,ename);

找到不重复的行

select * from e01 a where not exists (select 1 from e01 e where a.rowid!=e.rowid and e.empno=a.empno);

去掉重复的行：

select * from e01 a where rowid in (select max(rowid) from e01 e where e.empno=a.empno);

SQL语句-表的管理总结

对象命名规则

    由数字、字母、_、$、#组成
    表名和列名必须以字母开头，长度为1-30个字符
    同一个用户不能拥有两个同名的对象
    名字中不能使用Oracle服务器的保留字
    不区分大小写
    双引号打破规则

管理的对象
对象 	新建 	修改 	删除 	查看 	数据字典
表 	create table 	alter table 	drop table 	desc;select 	user_tables
约束 	create table add constraint 	alter table modify constraint 	alter table drop constraint 	desc 	user_constraints
视图 	create view 	no 	drop view 	select 	user_views
序列 	create sequence 	alter sequence 	drop sequence 	select 	no
索引 	create index 		drop index 	select 	user_indexes user_ind_columns index_stats
同义词 	create synonym 	no 	drop synonym 		
常用查询

sysdba用户查看所有的对象

SQL> select segment_name,blocks from user_segments;

sysdba用户查看所有的对象

select table_name from dba_tables;

scott用户拥有的rw以及可查看ro的对象

select table_name from all_tables;

scott用户拥有的表rw权限

select table_name from user_tables;

sysdba用户查看scn

select current_scn from v$database;

查看约束状态

select CONSTRAINT_NAME,STATUS,VALIDATED from user_constraints where table_name='T01';

scott用户拥有的视图

select view_name ,text from user_views;

查看序列的当前值和下一个值

select seq_empno.currval,seq_empno.nextval from dual;

查看索引情况

select index_name,blevel,num_rows from user_ind_statistics;

分析索引结构有效性 index_stats记录的时当前会话中最近一次的分析索引情况

create index i_e01 on e01 (deptno);
analyze index i_e01 validate structure;
select name,height,blocks,br_blks,br_rows,lf_blks,lf_rows from index_stats;

打开scott用户的信息搜集

begin
dbms_stats.gather_schema_stats(ownname=>'scott',
estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE,
options=>'gather',
degree=>DBMS_STATS.AUTO_DEGREE,
method_opt=>'for all columns size repeat',
cascade=>TRUE);
END;
/

查看表的情况

SQL> select num_rows,blocks from user_tab_statistics;

查看建表语句

SET SERVEROUTPUT ON
SET LINESIZE 1000
SET FEEDBACK OFF
set long 99999           
set pagesize 4000  
select dbms_metadata.get_ddl('TABLE','表名','用户名') from dual;
--注意参数必须大写


SQL> select dbms_metadata.get_ddl('TABLE','EMP','SCOTT') from dual;

DBMS_METADATA.GET_DDL('TABLE','EMP','SCOTT')
--------------------------------------------------------------------------------

  CREATE TABLE "SCOTT"."EMP"
   (	"EMPNO" NUMBER(4,0),
	"ENAME" VARCHAR2(10),
	"JOB" VARCHAR2(9),
	"MGR" NUMBER(4,0),
	"HIREDATE" DATE,
	"SAL" NUMBER(7,2),
	"COMM" NUMBER(7,2),
	"DEPTNO" NUMBER(2,0),
	 CONSTRAINT "PK_EMP" PRIMARY KEY ("EMPNO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE,
	 CONSTRAINT "FK_DEPTNO" FOREIGN KEY ("DEPTNO")
	  REFERENCES "SCOTT"."DEPT" ("DEPTNO") ENABLE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"

index_stats表分析
属性 	说明
height 	索引的高度，层级从0开始
blocks 	索引在后台占用多少块
br_blks 	索引分支有多少块
br_rows 	索引分支有多少行
lf_blks 	叶子有多少块
lf_rows 	叶子有多少行

st=>start: 查找empno为450的行
i_br=>inputoutpu: 索引分支(1-480的行在xx叶子节点上)
i_lf=>inputoutput: 索引叶子(450的行对应的rowid为xxx)
data_b=>inputoutput: 数据块
e=>end

st->i_br->i_lf->data_b->e

    所有的数据都是放在叶子节点上
    分支记录的是“范围+地址”
    叶子记录的时“关键字+rowid的一个组合”
    rowid是记录数据的物理地址

rowid的格式

rowid是64进制的

例如AAAVREAAEAAAACXAAI
对象id 	文件id 	块id 	row number
AAAVRE 	AAE 	AAAACX 	AAI
6位 	3位 	6位 	3位
object_id 	file_id 	block_id 	row number

    注意：在rowid中过的最后三位记录的row number是计算机记录的从0开始的，而我们在读表的时候使用的rownum是从1开始的。

PLSQL-变量_流程控制_数据类型_复合变量

为什么要使用 pl/sql

Database PL/SQL Language Reference

    便于维护(模块化)
    提高数据安全性和完整性(通过程序操作数据)
    提高性能(编译好的)
    简化代码(反复调用)

块的结构和声明变量

    块：是 PL/SQL 的基石；程序都是通过块组成。
    匿名块：没有名称的块叫匿名块，完成一定的功能。

模块的组成 	说明 	是否必要
DECLARE 	变量声明部分 	非
Begin 	逻辑处理执行部分的开始 	是
Exception 	错误处理部分 	非
End 	逻辑处理结束 	是
/ 	Begin 语句的提交 	是

--是行注释
/* */是多行注释
declare
  --私有变量声明
begin
  --代码主体
exception
  --异常处理
end;
/

使用变量
变量的优点

    用来存储数据
    操作存储的数据
    可以重复应用
    使维护工作简单

设置变量的语法

identifier [CONSTANT] datatype [NOT NULL] [:= | DEFAULT expr];

    [ ]内为可选项
    每行定义一个变量
    在 declare 部分声明
    如果设置了Not null 一定要给初值
    CONSTANT 也一定要给值
    := 为赋值，=为逻辑判断，判断是否相等。

变量的命名规则

    在不同的模块中，变量可以重名
    变量的名称不应该和模块中引用的列的名称相同
    变量名称应该有一定的可读性

变量的作用范围

    外部模块变量可以传到内部模块
    内部模块的变量不会影响外部

%TYPE属性

    声明一个变量和某列数据类型相同
    声明一个变量和另外一个变量数据类型一致

减小程序的无效的可能性，可以不知道列的数据类型，定义一个与之相同的变量。

v_name emp.ename%TYPE;
v_balance NUMBER(7,2);
v_min_balance v_balance%TYPE := 10;

流程控制
条件判断
IF条件判断

分支就是树的结构，条件就是分支的选择，我们只能走到一个支干上，即使每个条件都符合，我们也只能 操作一个支干的语句。

    IF-THEN-END IF
    IF-THEN-ELSE-END IF
    IF-THEN-ELSIF-END IF

语法

IF condition
THEN statements;
[ELSIF condition THEN statements;]
[ELSE
statements;]
END IF;

CASE条件判断

语法

CASE v1
WHEN 'A' THEN 'Excellent'
WHEN 'B' THEN 'Very Good'
WHEN 'C' THEN 'Good'
ELSE 'No such grade'
END;

循环
Loop循环

Declare
v1 number(2) :=1;
Begin
Loop
insert into t1 values (v1);
v1:=v1+1;
Exit When v1>10 ;
End loop;
End; /

建立实验表 t1，我们将想 t1 表中加入数据。

drop table t1 purge;
create table t1 (c1 number(2));
select * from t1;

Loop 循环必须含有退出的条件，而且该条件一定要每次循环都要变化，如果没有变化就是死循环，死循环的结果就是 cpu 总是 100%，你可以重新启动数据库来消除死循环。
While 循环

While 循环，先判定条件，每次循环时条件都要变化，如果不变化就是死循环。

Declare
V1 number(2) :=1;
Begin
While v1<10 Loop
Insert into t1 values(v1);
v1:=v1+1;
End loop;
End;
/

For循环

For循环，pl/sql中的最常见的循环，是和游标操作的绝配。方便而直观。

begin
for v1 in 1..9 loop
Insert into t1 values(v1);
end loop;
end;
/

begin
for v1 in REVERSE 1..9 loop
Insert into t1 values(v1);
end loop;
end;
/

For 循环特点

    步长为 1
    计数器不要声明，自动声明
    对计数器只能引用。不能做赋值操作
    计数器的数据类型和上下界的数据类型相同
    计数器只能在循环体内引用

数据类型

每个PL / SQL常量，变量，参数和函数返回值都有一个 确定其存储格式以及其有效值和操作的数据类型。

    scalar data types 标量数据类型
    composite data types 组合数据类型

scalar data types标量数据类型

PL / SQL在包中预定义了许多类型和子类型，STANDARD并允许您定义自己的子类型。
PL / SQL标量数据类型 	说明
SQL数据类型 	SQL Data Types
BOOLEAN 	布尔值
PLS_INTEGER 	该PLS_INTEGER数据类型存储范围为-2147483648到2,147,483,647符号整数，在32位表示。
PLS_INTEGER数据类型 与 NUMBER数据类型及NUMBER 子类型对比的优点：
1) PLS_INTEGER 值需要较少的存储空间。
2) PLS_INTEGER操作使用硬件算术，因此它们比NUMBER使用库算法的操作快。
为了提高效率，请PLS_INTEGER在其范围内的所有计算中使用值。
BINARY_INTEGER 	PL / SQL数据类型 PLS_INTEGER并且BINARY_INTEGER是相同的
REF CURSOR 	游标变量"Cursor Variables"
User-defined subtypes 	子类型可以：
- 提供与ANSI / ISO数据类型的兼容性
- 显示该类型数据项的预期用途
- 检测超出范围的值
SQL数据类型
Data Type 	Maximum Size in PL/SQL 	Maximum Size in SQL
CHARFoot 1 	32,767 bytes 	2,000 bytes
NCHARFootref 1 	32,767 bytes 	2,000 bytes
RAWFootref 1 	32,767 bytes 	2,000 bytes
VARCHAR2Footref 1 	32,767 bytes 	4,000 bytes
NVARCHAR2Footref 1 	32,767 bytes 	4,000 bytes
LONGFoot 2 	32,760 bytes 	2 gigabytes (GB) - 1
LONG RAWFootref 2 	32,760 bytes 	2 GB
BLOB 	128 terabytes (TB) 	(4 GB - 1) * database_block_size
CLOB 	128 TB 	(4 GB - 1) * database_block_size
NCLOB 	128 TB 	(4 GB - 1) * database_block_size
BOOLEAN

TRUE or FALSE
BINARY_INTEGER 和BINARY_INTEGER

PL / SQL数据类型 PLS_INTEGER并且BINARY_INTEGER是相同的。为简单起见，本文档使用PLS_INTEGER表示PLS_INTEGER和BINARY_INTEGER。

该PLS_INTEGER数据类型存储范围为-2147483648到2,147,483,647符号整数，在32位表示。

该PLS_INTEGER数据类型有这些优点在NUMBER数据类型及NUMBER亚型：

    PLS_INTEGER 值需要较少的存储空间。
    PLS_INTEGER操作使用硬件算术，因此它们比NUMBER使用库算法的操作快。

为了提高效率，请PLS_INTEGER在其范围内的所有计算中使用值。

话题

    防止PLS_INTEGER溢出
    预定义的PLS_INTEGER子类型
    PLS_INTEGER的SIMPLE_INTEGER子类型

REF CURSOR

游标变量Cursor Variables
Declaring and Defining Explicit Cursors

You can either declare an explicit cursor first and then define it later in the same block, subprogram, or package, or declare and define it at the same time.

An explicit cursor declaration, which only declares a cursor, has this syntax:

CURSOR cursor_name [ parameter_list ] RETURN return_type;

An explicit cursor definition has this syntax:

CURSOR cursor_name [ parameter_list ] [ RETURN return_type ]
  IS select_statement;

If you declared the cursor earlier, then the explicit cursor definition defines it; otherwise, it both declares and defines it.

DECLARE
  CURSOR c1 RETURN departments%ROWTYPE;    -- Declare c1

  CURSOR c2 IS                             -- Declare and define c2
    SELECT employee_id, job_id, salary FROM employees
    WHERE salary > 2000;

  CURSOR c1 RETURN departments%ROWTYPE IS  -- Define c1,
    SELECT * FROM departments              -- repeating return type
    WHERE department_id = 110;

  CURSOR c3 RETURN locations%ROWTYPE;      -- Declare c3

  CURSOR c3 IS                             -- Define c3,
    SELECT * FROM locations                -- omitting return type
    WHERE country_id = 'JP';
BEGIN
  NULL;
END;
/

User-defined subtypes

子类型可以：

    提供与ANSI / ISO数据类型的兼容性
    显示该类型数据项的预期用途
    检测超出范围的值

话题

    无约束子类型
    约束子类型
    相同数据类型族中具有基本类型的子类型

composite data types组合数据类型

一种 复合数据类型 存储具有内部组件的值。您可以将整个复合变量作为参数传递给子程序，并且可以访问以下组件的内部组件：分别组合变量。内部组件可以是标量或复合的。您可以在任何可以使用标量变量的地方使用标量组件。PL / SQL使您可以定义两种复合数据类型，即收集和记录。您可以在可以使用相同类型的复合变量的任何地方使用复合组件。

注意：

如果您将复合变量作为参数传递给 远程子程序，则必须创建一个冗余的loop-back DATABASE LINK，以便在编译远程子程序时，验证源的类型检查器使用与调用方相同的用户定义复合变量类型定义。有关该CREATE DATABASE LINK语句的信息，请参见《Oracle数据库SQL语言参考》。

    在一个 collection ，内部组件始终具有相同的数据类型，并且被称为元素。您可以通过其唯一性来访问集合变量的每个元素索引，使用以下语法：variable_name``(``index``)。要创建集合变量，您可以定义一个集合类型，然后创建该类型的变量或使用%TYPE。

    在一个 record ，内部组件可以具有不同的数据类型，并且被称为Field。您可以使用以下语法按其名称访问记录变量的每个字段：variable_name.field_name。要创建记录变量，您可以定义一个RECORD类型，然后创建该类型的变量，或者使用%ROWTYPE或%TYPE。

您可以创建记录的集合以及包含集合的记录。

收藏主题

    集合类型
    关联数组
    Varrays（可变大小数组）
    嵌套表
    集合构造器
    将值分配给集合变量
    多维集合
    集合比较
    收集方法
    包装规格中定义的收集类型

复合变量

Oracle 数据库中有两个引擎,SQL 引擎和 PL\SQL 引擎,我们在 pl/sql 的模块中调用了 sql 语句,数据库就要 在两个引擎中来回的切换，如果我们使用循环来处理SQL语句的话,就会造成频繁的在两个引擎中进行切换.。

为了避免这样的情况发生，我们最好是将要传递的值放入到复合变量中，一次传递更多的数据，这个技术叫 做批量绑定。

PL/SQL Collections and Records
PL/SQL RECORDs

在一个 record，内部组件可以具有不同的数据类型，并且被称为域Field。您可以使用以下语法按其名称访问记录变量的每个字段：variable_name.field_name。要创建记录变量，您可以定义一个RECORD类型，然后创建该类型的变量，或者使用%ROWTYPE或%TYPE。

%ROWTYPE 属性可让您声明一个记录变量 表示数据库表或视图的全部或部分行。对于完整或部分行的每一列，记录都有一个具有相同名称和数据类型的字段。如果行的结构发生变化，那么记录的结构也会发生变化。

记录字段不继承相应列的约束或初始值（请参见示例5-39）。

话题

    记录变量始终代表完整行
    记录可以代表部分行的变量
    ％ROWTYPE属性和虚拟列

记录变量始终代表完整行

要声明一个始终代表数据库表或视图的完整行的记录变量，请使用以下语法：

variable_name  table_or_view_name％ROWTYPE;

对于表或视图的每一列，记录都有一个具有相同名称和数据类型的字段
记录可以代表部分行的变量

要声明一个可以代表数据库表或视图的部分行的记录变量，请使用以下语法：

variable_name cursor%ROWTYPE;

％ROWTYPE属性和虚拟列

如果您使用 %ROWTYPE 属性以定义一个记录变量，该记录变量表示具有 虚拟列，则无法将该记录插入表中。相反，您必须将各个记录字段插入到表中，但不包括虚拟列。

例5-42创建了一个记录变量，该变量代表具有虚拟列的表的完整行，填充该记录，并将该记录插入到表中，从而导致ORA-54013。

    前缀为表的名称

    内部域的属性为表中列的数据类型

    域的名称为列的名称

    便于存储表的一行

PL/SQL Collections

在一个 collection，内部组件始终具有相同的数据类型，并且被称为元素。您可以通过其唯一性来访问集合变量的每个元素索引，使用以下语法：variable_name(index)。要创建集合变量，您可以定义一个集合类型，然后创建该类型的变量或使用%TYPE。

表面上看象数组，但不是，它更象一个带有主键的表，我们通过主键来访问数据。 含有两要素:

    主键，数据类型为 BINARY_INTEGER
    成员，可以为简单变量，也可以为记录复合变量

TYPE type_name IS TABLE OF
{column_type | variable%TYPE
| table.column%TYPE} [NOT NULL]
| table.%ROWTYPE
[INDEX BY BINARY_INTEGER];
identifier type_name;

实践
实践1-书写一个最简单的块，运行并查看结果

    先设定 SQLPLUS 的环境变量，如果不指定默认值为不输出，设定后用 show 来验证。

set serveroutput on
show serveroutput

该实验的目的是掌握简单的 pl/sql 语法，执行一个最简单的匿名块。

书写一个最简单的块，将字符串输出到屏幕。使用的是 sqlplus 输出 Hello world。

begin
dbms_output.put_line('-----------------Begin------------------');
dbms_output.put_line('hello world');
dbms_output.put_line('-----------------End------------------');
end;
/

每句话以分号结束，最后加上 /。
实践2-在块中操作变量

该实验的目的是掌握在 pl/sql 块中操作变量。

说出一下变量定义的含义。

DECLARE
v_hiredate DATE;
v_deptno NUMBER(2) NOT NULL := 10;
v_location VARCHAR2(13) := 'Atlanta';
c_comm CONSTANT NUMBER := 1400;
v_valid BOOLEAN NOT NULL := TRUE;
begin
dbms_output.put_line('-----------------Begin------------------');
dbms_output.put_line('v_hiredate:' || v_hiredate );
dbms_output.put_line('v_deptno' || v_deptno);
dbms_output.put_line('v_location' || v_location);
dbms_output.put_line('c_comm:' || c_comm );
dbms_output.put_line('-----------------End------------------');
end;
/

实践3-在块中操作变量理解%TYPE属性

该实验的目的是掌握参数定义时的%TYPE属性。

DECLARE
v_sal NUMBER (9,2);
g_monthly_sal v_sal%TYPE := 10;
BEGIN
/* Compute the annual salary based on the
monthly salary input from the user */
v_sal := g_monthly_sal * 12;
dbms_output.put_line(v_sal);
END; -- This is the end of the block
/

实践4-在块中操作表的数据

该实验的目的是掌握在 pl/sql 块中操作数据库中的表，通过select..into..将表中的数据放入到变量。

    取表中的数据

    一定要有 into
    一次只能操作一行，
    操作多行得用循环
    变量类型和个数要匹配

declare
v1 emp.ename%type;
v2 emp.sal%type;
begin
select ename,sal into v1,v2 from emp where empno=7900;
dbms_output.put_line(v1);
dbms_output.put_line(v2);
end;
/

    删除表中的数据并打印删除的行数

DML 语句和 SQL 相同，使用隐式游标的属性来控制 DML，有四种隐式的游标：

    SQL%ROWCOUNT
    SQL%FOUND
    SQL%NOTFOUND
    SQL%ISOPEN

declare
v1 emp.deptno%type :=20;
v2 number;
begin
delete emp where deptno=v1;
v2:=sql%rowcount;
dbms_output.put_line('delete rows :');
dbms_output.put_line(v2);
rollback;
end;
/

执行结果

SCOTT@testdb>select * from emp where deptno=20;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7566 JONES      MANAGER	      7839 02-APR-81	   2975 		   20
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3000 		   20
      7876 ADAMS      CLERK	      7788 23-MAY-87	   1100 		   20
      7902 FORD       ANALYST	      7566 03-DEC-81	   3000 		   20

declare
v1 emp.deptno%type :=20;
v2 number;
begin
    delete emp where deptno=v1;
    v2:=sql%rowcount;
    dbms_output.put_line('delete rows :');
    dbms_output.put_line(v2);
    rollback;
end;
/


PL/SQL procedure successfully completed.

实践5-在块中的分支操作IF语句

该实验的目的是掌握在 pl/sql 块中使用 if 语句进行分支操作。

DECLARE
v1 DATE := to_date('12-11-1990','mm-dd-yyyy');
v2 BOOLEAN;
BEGIN
IF MONTHS_BETWEEN(SYSDATE,v1) > 5 THEN
v2 := TRUE;
dbms_output.put_line('True');
ELSE
v2 := FALSE;
dbms_output.put_line('False');
END IF;
end;
/

结果

True

PL/SQL procedure successfully completed.

实践6-在块中的分支操作CASE语句

该实验的目的是掌握在 pl/sql 块中使用 CASE 语句进行分支操作。

DECLARE
v1 CHAR(1) := UPPER('&v1');
v2 VARCHAR2(20);
BEGIN
v2 :=CASE v1
WHEN 'A' THEN 'Excellent'
WHEN 'B' THEN 'Very Good'
WHEN 'C' THEN 'Good'
ELSE 'No such grade'
END;
DBMS_OUTPUT.PUT_LINE (v1 || ' is  ' || v2); END;
/

Null 的逻辑运算真值表

    True and null 结果为 null
    Flase and null 结果为 flase

实践7-在块中使用三种循环for.while.loop

该实验的目的是掌握 pl/sql 块中使用 三种 循环的语法。

打印乘法口诀。

-- for
declare
s varchar2(2000) := '';
begin
for i in 1..9 loop
  s := '';
	for j in 1..i loop
			s := s || j || ' * ' || i || ' = ' || i*j || '    ';
	end loop;
	dbms_output.put_line(s);
end loop;
end;
/

-- while
declare
s varchar2(2000) := '';
i number :=1;
j number :=1;
begin
while i <= 9 loop
  s := '';
	j := 1;
	while j <= i loop
			s := s || j || ' * ' || i || ' = ' || i*j || '    ';
			j := j + 1;
	end loop;
	dbms_output.put_line(s);
	i := i + 1;
end loop;
end;
/

-- loop
declare
s varchar2(2000) := '';
i number :=1;
j number :=1;
begin
loop
  s := '';
	j := 1;
	loop
			s := s || j || ' * ' || i || ' = ' || i*j || '    ';
			j := j + 1;
  	exit when j > i; 		
	end loop;
	dbms_output.put_line(s);
	i := i + 1;
exit when i > 9;
end loop;
end;
/

运行结果

1 * 1 = 1    
1 * 2 = 2    2 * 2 = 4    
1 * 3 = 3    2 * 3 = 6    3 * 3 = 9    
1 * 4 = 4    2 * 4 = 8    3 * 4 = 12    4 * 4 = 16    
1 * 5 = 5    2 * 5 = 10    3 * 5 = 15    4 * 5 = 20    5 * 5 = 25    
1 * 6 = 6    2 * 6 = 12    3 * 6 = 18    4 * 6 = 24    5 * 6 = 30    6 * 6 = 36    
1 * 7 = 7    2 * 7 = 14    3 * 7 = 21    4 * 7 = 28    5 * 7 = 35    6 * 7 = 42    7 * 7 = 49    
1 * 8 = 8    2 * 8 = 16    3 * 8 = 24    4 * 8 = 32    5 * 8 = 40    6 * 8 = 48    7 * 8 = 56    8 * 8 = 64    
1 * 9 = 9    2 * 9 = 18    3 * 9 = 27    4 * 9 = 36    5 * 9 = 45    6 * 9 = 54    7 * 9 = 63    8 * 9 = 72    9 * 9 = 81    

三种循环，个人最喜欢for。^.^
实践8-在块中自定义RECORD类型定义和变量声明

自定义数据类型

    定义新的数据类型DeptRecTyp
    声明变量 dept_rec的数据类型为 DeptRecTyp
    声明变量 dept_rec_2 的数据类型与 dept_rec的类型相同

DECLARE
  TYPE DeptRecTyp IS RECORD (
    dept_id    NUMBER(4) NOT NULL := 10,
    dept_name  VARCHAR2(30) NOT NULL := 'Administration',
    mgr_id     NUMBER(6) := 200,
    loc_id     NUMBER(4)
  );

  dept_rec DeptRecTyp;
  dept_rec_2 dept_rec%TYPE;
BEGIN
  DBMS_OUTPUT.PUT_LINE('dept_rec:');
  DBMS_OUTPUT.PUT_LINE('---------');
  DBMS_OUTPUT.PUT_LINE('dept_id:   ' || dept_rec.dept_id);
  DBMS_OUTPUT.PUT_LINE('dept_name: ' || dept_rec.dept_name);
  DBMS_OUTPUT.PUT_LINE('mgr_id:    ' || dept_rec.mgr_id);
  DBMS_OUTPUT.PUT_LINE('loc_id:    ' || dept_rec.loc_id);

  DBMS_OUTPUT.PUT_LINE('-----------');
  DBMS_OUTPUT.PUT_LINE('dept_rec_2:');
  DBMS_OUTPUT.PUT_LINE('-----------');
  DBMS_OUTPUT.PUT_LINE('dept_id:   ' || dept_rec_2.dept_id);
  DBMS_OUTPUT.PUT_LINE('dept_name: ' || dept_rec_2.dept_name);
  DBMS_OUTPUT.PUT_LINE('mgr_id:    ' || dept_rec_2.mgr_id);
  DBMS_OUTPUT.PUT_LINE('loc_id:    ' || dept_rec_2.loc_id);
END;
/

运行结果

dept_rec:
---------
dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:
-----------
dept_rec_2:
-----------
dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:

实践9-在块中自定义RECORD字段的RECORD类型（嵌套记录Nested Record）

record类型可以理解为python中的字典dict

friend = {
  "name" : {
    "ename": "John",
    "job": "salesman",
  },
  "sal": 1000,
}
print(friend['name']['ename'],friend['name']['job'],friend['sal'])
# ('John', 'salesman', 1000)

使用PLSQL实现：

DECLARE
  TYPE name_rec IS RECORD (
    ename  emp.ename%TYPE,
    job   emp.job%TYPE
  );

  TYPE contact IS RECORD (
    name  name_rec,                    -- nested record
    sal emp.sal%TYPE
  );

  friend contact;
BEGIN
  friend.name.ename := 'John';
  friend.name.job := 'salesman';
  friend.sal := '1000';

  DBMS_OUTPUT.PUT_LINE (
    friend.name.ename  || ' ' ||
    friend.name.job   || ', ' ||
    friend.sal
  );
END;
/

运行结果

John salesman, 1000

实践10-在块中自定义RECORD字段的RECORD类型（％ROWTYPE属性）

    声明变量dept_rec的数据类型与 表dept相同
    赋予变量dept_rec的每个field一个值，并打印。

DECLARE
  dept_rec dept%ROWTYPE;
  dept_rec2 dept%ROWTYPE;
BEGIN
  -- Assign values to fields:

  dept_rec.DEPTNO  := 10;
  dept_rec.DNAME := 'Administration';
  dept_rec.LOC    := 'New York';
  select * into dept_rec2 from dept where rownum = 1;

  -- Print fields:

  DBMS_OUTPUT.PUT_LINE('DEPTNO:   ' || dept_rec.DEPTNO);
  DBMS_OUTPUT.PUT_LINE('DNAME: ' || dept_rec.DNAME);
  DBMS_OUTPUT.PUT_LINE('LOC:    ' || dept_rec.LOC);

  DBMS_OUTPUT.PUT_LINE('DEPTNO:   ' || dept_rec2.DEPTNO);
  DBMS_OUTPUT.PUT_LINE('DNAME: ' || dept_rec2.DNAME);
  DBMS_OUTPUT.PUT_LINE('LOC:    ' || dept_rec2.LOC);
END;
/

执行结果

DEPTNO:   10
DNAME: Administration
LOC:	New York
DEPTNO:   10
DNAME: ACCOUNTING
LOC:	NEW YORK

实践11-在块中自定义COLLECTIONS的类型

DECLARE
TYPE t1 IS TABLE OF emp.ename%TYPE
INDEX BY BINARY_INTEGER;
TYPE t2 IS TABLE OF DATE INDEX BY BINARY_INTEGER;
v1 t1;
v2 t2;
BEGIN
V1(0) := 'AA';
v1(1) := 'CAMERON';
v2(8) := SYSDATE + 7;
select ename,hiredate into v1(7900),v2(7900) from emp where empno=7900; dbms_output.put_line(v1(1)||' '||v1(7900)); dbms_output.put_line(v2(8)||' '||v2(7900));
dbms_output.put_line(v1(0));
END;
/


DECLARE
TYPE t1 IS TABLE OF emp.ename%TYPE
INDEX BY BINARY_INTEGER;
v1 t1;
BEGIN
V1(0) := 'AA';
v1(1) := 'CAMERON';
dbms_output.put_line(v1(1));
END;
/

DECLARE
TYPE t1 IS TABLE OF NUMBER;
v1 t1 := t1(1,2,3);
BEGIN
dbms_output.put_line(v1(1));
END;
/

实践12-使用集合的属性来操作集合的数据
方法 	类型 	描述
DELETE 	程序 	从集合中删除元素。
TRIM 	程序 	从varray或嵌套表的末尾删除元素。
EXTEND 	程序 	将元素添加到varray或嵌套表的末尾。
EXISTS 	功能 	TRUE当且仅当存在varray或嵌套表的指定元素时才返回。
FIRST 	功能 	返回集合中的第一个索引。
LAST 	功能 	返回集合中的最后一个索引。
COUNT 	功能 	返回集合中元素的数量。
LIMIT 	功能 	返回集合可以具有的最大元素数。
PRIOR 	功能 	返回指定索引之前的索引。
NEXT 	功能 	返回在指定索引之后的索引。

DECLARE
  type nt_type is  table of number;
  nt nt_type := nt_type(11, 22, 33, 44, 55, 66);
  PROCEDURE print_nt(nt nt_type) IS
  	i number;
  begin
  	i := nt.FIRST;
  	IF i IS NULL THEN
    	DBMS_OUTPUT.PUT_LINE('nt is empty');
  	ELSE
    	WHILE i IS NOT NULL LOOP
      	DBMS_OUTPUT.PUT('nt.(' || i || ') = ');
        DBMS_OUTPUT.PUT(nt(i));
        DBMS_OUTPUT.PUT_line('');
      	i := nt.NEXT(i);
    	END LOOP;
    END IF;
    DBMS_OUTPUT.PUT_line('==========================');
  END;
BEGIN
  print_nt(nt);

  nt.DELETE(2);     -- Delete second element
  print_nt(nt);

  nt(2) := 2222;    -- Restore second element
  print_nt(nt);

  nt.DELETE(2, 4);  -- Delete range of elements
  print_nt(nt);

  nt(3) := 3333;    -- Restore third element
  print_nt(nt);

  nt.DELETE;        -- Delete all elements
  print_nt(nt);
END;
/

结果

nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
==========================
nt.(1) = 11
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
==========================
nt.(1) = 11
nt.(2) = 2222
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
==========================
nt.(1) = 11
nt.(5) = 55
nt.(6) = 66
==========================
nt.(1) = 11
nt.(3) = 3333
nt.(5) = 55
nt.(6) = 66
==========================
nt is empty
==========================

实践13-成员为复合变量，每个主键访问一行数据

DECLARE
TYPE t1 IS TABLE OF emp%rowtype INDEX BY BINARY_INTEGER;
TYPE t2 IS TABLE OF dept%rowtype INDEX BY BINARY_INTEGER;
v1 t1;
v2 t2;
BEGIN
select * into v1(7900) from emp where empno=7900;
select * into v2(10) from dept where deptno=10; dbms_output.put_line(v1(7900).empno||v1(7900).ename); dbms_output.put_line(v2(10).dname);
END;
/

实践14-在块中使用自定义游标

DECLARE
CURSOR c1 is select ename,sal from emp order by sal desc;
v1 c1%rowtype;
BEGIN
open c1;
fetch c1 into v1;
dbms_output.put_line(v1.ename || ': ' ||v1.sal);
fetch c1 into v1;
dbms_output.put_line(v1.ename || ': ' ||v1.sal);
close c1;
END;
/

实践15--在块中使用自定义游标和游标的属性

游标的属性:

前缀为游标的名称

    %isopen，测试该游标是否打开，返回真或假
    %rowcount，游标已经操作了多少行， 返回数值
    %found，游标是否找到记录，返回真或假
    %notfound，游标是否找到记录，返回真或假

DECLARE
CURSOR c1 is select ename,sal from emp order by sal desc; v1 c1%rowtype;
n1 number(2);
BEGIN
if not c1%isopen then
open c1;
end if;
fetch c1 into v1;
n1:=c1%rowcount;
dbms_output.put_line(v1.ename||' '||v1.sal||' '||n1); close c1;
END;
/

实践16-在块中使用自定义游标和循环控制

DECLARE
 CURSOR c1 is select ename,sal from emp order by sal desc;
 v1 c1%rowtype;
 n1 number(2);
BEGIN
 open c1;
 loop fetch c1 into v1;
 	exit when c1%notfound;
 	dbms_output.put_line(v1.ename||' '||v1.sal);
 	n1:=c1%rowcount;
 end loop;
 close c1;
 dbms_output.put_line(n1);
END;
/

-- For 循环
DECLARE
 CURSOR c1 is select ename,sal from emp order by sal desc;
 n1 number(2);
BEGIN
 for v1 in c1 loop
   dbms_output.put_line(v1.ename||' '||v1.sal);
   n1:=c1%rowcount;
 end loop;
 dbms_output.put_line(n1);
 END;
 /

    v1 的数据类型为 c1%rowtype
    c1 自动 open,自动 fetch,自动 close
    for 循环和游标的结合可以很方便的 处理游标内的每一行。

实践18-在块中使用自定义游标之带变量的游标

    带变量的游标，每次打开游标的时候需要给定变量。

    根据变量的不同，游标的内容将不同。

    一般用于多层循环中内层循环的游标控制。

DECLARE
 CURSOR c1(n1 number) is select ename,sal from emp where empno=n1;
 v1 c1%rowtype;
BEGIN
 open c1(7900);
 fetch c1 into v1;
 dbms_output.put_line(v1.ename||' '||v1.sal);
 close c1;
END;
/

课后练习

准备实验环境，建立一个表，其中一个列是空的，我们要将空列的值赋予相对应的部门名称。

conn scott/tiger
drop table t1 purge;
create table t1 as select ename,deptno from emp;
alter table t1 add(dname varchar2(18));
select * from t1;

执行结果

SCOTT@testdb>select * from t1;

ENAME	       DEPTNO DNAME
---------- ---------- ------------------
test1		   50
test		   50
SMITH		   20
ALLEN		   30
WARD		   30
JONES		   20
MARTIN		   30
BLAKE		   30
CLARK		   10
SCOTT		   20
KING		   10
TURNER		   30
ADAMS		   20
JAMES		   30
FORD		   20
MILLER		   10
booboo		   50

17 rows selected.

答案：

DECLARE
 CURSOR c1 is select * from t1 for update;
 v1 dept.dname%type;

BEGIN
 for n1 in c1 loop
   select dname into v1 from dept where deptno=n1.deptno;
   update t1 set dname=v1 WHERE CURRENT OF C1;
 end loop;
 END;
 /

检查

SCOTT@testdb>select * from t1;

ENAME	       DEPTNO DNAME
---------- ---------- ------------------
test1		   50 test
test		   50 test
SMITH		   20 RESEARCH
ALLEN		   30 SALES
WARD		   30 SALES
JONES		   20 RESEARCH
MARTIN		   30 SALES
BLAKE		   30 SALES
CLARK		   10 ACCOUNTING
SCOTT		   20 RESEARCH
KING		   10 ACCOUNTING
TURNER		   30 SALES
ADAMS		   20 RESEARCH
JAMES		   30 SALES
FORD		   20 RESEARCH
MILLER		   10 ACCOUNTING
booboo		   50 test

17 rows selected.

PLSQL-异常处理_匿名块

异常处理

官方文档

PL/SQL Error Handling

Exception Declaration
异常处理程序的优点

使用异常处理程序进行错误处理可以使程序更易于编写和理解，并减少未处理异常的可能性。

如果没有异常处理程序，则必须检查所有可能发生的错误（可能发生的任何地方），然后进行处理。很容易忽略可能的错误或可能发生的地方，尤其是在无法立即检测到错误的情况下（例如，在您将其用于计算之前，可能无法检测到错误的数据）。错误处理代码分散在整个程序中。

使用异常处理程序，您不必知道每个可能的错误或任何可能发生的错误。您只需要在可能发生错误的每个块中包括一个异常处理部分。在异常处理部分，您可以包括针对特定错误和未知错误的异常处理程序。如果该块中任何地方（包括子块内部）发生错误，则由异常处理程序进行处理。错误处理代码隔离在块的异常处理部分中。

在示例11-3中，过程使用单个异常处理程序来处理预定义的异常NO_DATA_FOUND，该异常可能发生在两个SELECT INTO语句中的任何一个中。
异常处理的语法

异常（PL / SQL运行时错误）可能源于设计错误，编码错误，硬件故障和许多其他来源。您无法预期所有可能的异常，但是可以编写异常处理程序，可让您的程序在存在的情况下继续运行。

任何PL / SQL块都可以具有一个异常处理部分，该部分可以具有一个或多个异常处理程序。例如，异常处理部分可能具有以下语法：

EXCEPTION
  WHEN ex_name_1 THEN statements_1                  -异常处理
  WHEN ex_name_2 OR ex_name_3 THEN statements_2   -异常处理
  WHEN OTHERS THEN statements_3                       -例外处理程序
END;

在前面的语法示例中，ex_name_``n是异常的名称，并且statements_``n是一个或多个语句。（有关完整的语法和语义，请参阅“异常处理程序”。）

当块的可执行部分中引发异常时，可执行部分将停止并将控制权转移到异常处理部分。如果ex_name_1有人提出来，那statements_1就跑。如果任一ex_name_2或被ex_name_3提出，然后statements_2运行。如果引发了其他任何异常，请statements_3运行。

运行异常处理程序后，控制权将转移到封闭块的下一条语句。如果没有封闭块，则：

    如果异常处理程序在子程序中，则控制在调用后的语句处返回到调用程序。
    如果异常处理程序位于匿名块中，则控制权将转移到主机环境（例如，SQL * Plus）

如果在没有异常处理程序的块中引发了异常，则该异常将传播。也就是说，异常会在连续的封闭块中重现，直到一个块具有针对它的处理程序或没有封闭块为止（有关更多信息，请参见“异常传播”）。如果没有用于异常的处理程序，则PL / SQL将未处理的异常错误返回给调用者或宿主环境，该错误确定结果（有关更多信息，请参见“未处理的异常”）。
异常的分类

    内部定义

    运行时系统隐式（自动）引发内部定义的异常。内部定义的异常的示例是ORA-00060（在等待资源时检测到死锁）和ORA-27102（内存不足）。

    内部定义的异常始终具有错误代码，但没有名称，除非PL / SQL给它一个或您给它一个。

    有关更多信息，请参见“内部定义的异常”。

    预定义

    预定义的异常是内部定义的异常，PL / SQL已为其指定了名称。例如，ORA-06500（PL / SQL：存储错误）具有预定义的名称STORAGE_ERROR。

    有关更多信息，请参见“预定义的异常”。

    用户自定义

    您可以在任何PL / SQL匿名块，子程序或程序包的声明部分中声明自己的异常。例如，您可以声明一个名称insufficient_funds为标记透支银行帐户的异常。

    您必须显式引发用户定义的异常。

    有关更多信息，请参见“用户定义的异常”。

类别 	定义者 	有错误代码 	有名字 	隐式提高 	明确提出
内部定义 	运行系统 	总是 	仅当您分配一个 	是 	可选脚1
预定义 	运行系统 	总是 	总是 	是 	可选的Footref 1
用户自定义 	用户 	仅当您分配一个 	总是 	没有 	总是

脚注1 有关详细信息，请参见“使用RAISE语句引发内部定义的异常”。

对于命名异常，您可以编写特定的异常处理程序，而不是使用OTHERS异常处理程序对其进行处理。特定的异常处理程序比异常处理程序更有效OTHERS，因为后者必须调用一个函数来确定要处理的异常。有关详细信息，请参见“错误代码和错误消息检索”。
处理内部定义异常

内部定义的异常（ORA- n错误）在Oracle数据库错误消息中进行了描述。运行时系统隐式（自动）引发它们。

内部定义的异常没有名称，除非PL / SQL给它一个（请参阅“预定义的异常”）或您给它一个。

如果您知道数据库操作可能会引发没有名称的特定内部定义的异常，请给它们命名，以便您可以专门为其编写异常处理程序。否则，您只能使用OTHERS异常处理程序来处理它们。

给一个 将其命名为内部定义的异常，请在相应的匿名块，子程序或程序包的声明部分中执行以下操作。（要确定适当的块，请参见“异常传播”。）
语法

    声明名称。

    异常名称声明具有以下语法：

    exception_name EXCEPTION;

    有关语义信息，请参见“异常声明”。

    将名称与内部定义的异常的错误代码相关联。

    语法为：

    PRAGMA EXCEPTION_INIT（exception_name，error_code）

    有关语义信息，请参见“ EXCEPTION_INIT语法”。

注意：

具有用户声明的名称的内部定义的异常仍然是内部定义的异常，而不是用户定义的异常。
案例

deadlock_detected内部定义的异常ORA-00060（在等待资源时检测到死锁）提供了名称，并在异常处理程序中使用了该名称。

DECLARE
  deadlock_detected EXCEPTION;
  PRAGMA EXCEPTION_INIT(deadlock_detected, -60);
BEGIN
  ...
EXCEPTION
  WHEN deadlock_detected THEN
    ...
END;
/

处理系统预定义异常

预定义异常是具有预定义名称的内部定义的异常，PL / SQL在包中全局声明了预定义名称STANDARD。运行时系统隐式（自动）引发预定义的异常。因为预定义的异常具有名称，所以您可以为其专门编写异常处理程序。

表11-3列出了预定义的异常的名称和错误代码。

表11-3 PL / SQL预定义的异常
例外名称 	错误代码
ACCESS_INTO_NULL 	-6530
CASE_NOT_FOUND 	-6592
COLLECTION_IS_NULL 	-6531
CURSOR_ALREADY_OPEN 	-6511
DUP_VAL_ON_INDEX 	-1
INVALID_CURSOR 	-1001
INVALID_NUMBER 	-1722
LOGIN_DENIED 	-1017
NO_DATA_FOUND 	+100
NO_DATA_NEEDED 	-6548
NOT_LOGGED_ON 	-1012
PROGRAM_ERROR 	-6501
ROWTYPE_MISMATCH 	-6504
SELF_IS_NULL 	-30625
STORAGE_ERROR 	-6500
SUBSCRIPT_BEYOND_COUNT 	-6533
SUBSCRIPT_OUTSIDE_LIMIT 	-6532
SYS_INVALID_ROWID 	-1410
TIMEOUT_ON_RESOURCE 	-51
TOO_MANY_ROWS 	-1422
VALUE_ERROR 	-6502
ZERO_DIVIDE 	-1476
语法

exception
  when no_data_found then

案例

declare
  v_ename emp.ename%type;
  v_sal emp.sal%type;
/*
-1:未选定行
*/
  v_err number;
begin
  select ename,sal into v_ename,v_sal from emp where empno=&p_empno;
  v_err:=0;
  dbms_output.put_line(v_err);
exception
  when no_data_found then
    v_err:=-1;
    dbms_output.put_line(v_err);
end;
/

运行结果

ACCESS_INTO_NULL -6530
CASE_NOT_FOUND -6592
COLLECTION_IS_NULL -6531
CURSOR_ALREADY_OPEN -6511
DUP_VAL_ON_INDEX -1
INVALID_CURSOR -1001
INVALID_NUMBER -1722
LOGIN_DENIED -1017
NO_DATA_FOUND +100
NO_DATA_NEEDED -6548
NOT_LOGGED_ON -1012
PROGRAM_ERROR -6501
ROWTYPE_MISMATCH -6504
SELF_IS_NULL -30625
STORAGE_ERROR -6500
SUBSCRIPT_BEYOND_COUNT -6533
SUBSCRIPT_OUTSIDE_LIMIT -6532
SYS_INVALID_ROWID -1410
TIMEOUT_ON_RESOURCE -51
TOO_MANY_ROWS -1422
VALUE_ERROR -6502

处理自定义异常

您可以在任何PL / SQL匿名块，子程序或程序包的声明部分中声明自己的异常。
语法

异常名称声明具有以下语法：

exception_name EXCEPTION;

有关语义信息，请参见“异常声明”。

您必须显式引发用户定义的异常。有关详细信息，请参见“显式引发异常”。
RAISE声明

的 RAISE语句显式引发异常。在异常处理程序之外，您必须指定异常名称。在异常处理程序内部，如果省略了异常名称，则该RAISE语句将重新引发当前的异常。
RAISE_APPLICATION_ERROR过程

您可以调用 RAISE_APPLICATION_ERROR``DBMS_STANDARD仅在存储的子程序或方法中执行过程（在包中定义）。通常，您调用此过程来引发用户定义的异常，并将其错误代码和错误消息返回给调用者。

要调用RAISE_APPLICATION_ERROR，请使用以下语法：

RAISE_APPLICATION_ERROR（error_code，消息 [，{TRUE | FALSE}]）；

您必须使用分配error_code给用户定义的异常EXCEPTION_INIT实用 语法为：

PRAGMA EXCEPTION_INIT（exception_name，error_code）

有关语义信息，请参见“ EXCEPTION_INIT语法”。
案例-RAISE

DECLARE
  salary_too_high   EXCEPTION;
  current_salary    NUMBER := 20000;
  max_salary        NUMBER := 10000;
  erroneous_salary  NUMBER;
BEGIN

  BEGIN
    IF current_salary > max_salary THEN
      RAISE salary_too_high;   -- raise exception
    END IF;
  EXCEPTION
    WHEN salary_too_high THEN  -- start handling exception
      erroneous_salary := current_salary;
      DBMS_OUTPUT.PUT_LINE('Salary ' || erroneous_salary ||' is out of range.');
      DBMS_OUTPUT.PUT_LINE ('Maximum salary is ' || max_salary || '.');
      RAISE;  -- reraise current exception (exception name is optional)
  END;

EXCEPTION
  WHEN salary_too_high THEN    -- finish handling exception
    current_salary := max_salary;

    DBMS_OUTPUT.PUT_LINE (
      'Revising salary from ' || erroneous_salary ||
      ' to ' || current_salary || '.'
    );
END;
/

Result:

Salary 20000 is out of range.
Maximum salary is 10000.
Revising salary from 20000 to 10000.

案例2-RAISE_APPLICATION_ERROR

CREATE PROCEDURE account_status (
  due_date DATE,
  today    DATE
) AUTHID DEFINER
IS
BEGIN
  IF due_date < today THEN                   -- explicitly raise exception
    RAISE_APPLICATION_ERROR(-20000, 'Account past due.');
  END IF;
END;
/

DECLARE
  past_due  EXCEPTION;                       -- declare exception
  PRAGMA EXCEPTION_INIT (past_due, -20000);  -- assign error code to exception
BEGIN
  account_status ('1-JUL-10', '9-JUL-10');   -- invoke procedure
EXCEPTION
  WHEN past_due THEN                         -- handle exception
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(SQLERRM(-20000)));
END;
/

Result:

ORA-20000: Account past due.

课后练习
练习1-使用函数sqlerrm打印ORA-消息描述

/* 使用函数sqlerrm打印ORA-消息描述：*/
declare
  errm varchar2(1000);
begin
  for errno in 20000..20999 loop
    errm:=sqlerrm(-errno);
    dbms_output.put_line(errm);
  end loop;
end;
/

练习2-处理系统预定义异常

    捕获到no_data_found；则输出-1：
    捕获到too_many_row；则输出查询返回太多行;
    捕获到其他异常，则输出未知错误。

declare
  v_ename emp.ename%type;
  v_sal emp.sal%type;
  v_err number;
begin
  update emp set deptno=80 where empno=7839;
  select ename,sal into v_ename,v_sal from emp where deptno=&p_deptno;
  v_err:=0;
    dbms_output.put_line(v_err);
exception
  when no_data_found then
    v_err:=-1;
    dbms_output.put_line(v_err);
  when too_many_rows then
    dbms_output.put_line('查询返回太多行');
  when others then
    dbms_output.put_line('未知错误');
end;
/

练习3-处理内部定义异常ORA-02291

[oracle@NB-flexgw1 ~]$ oerr ora 2291
02291, 00000,"integrity constraint (%s.%s) violated - parent key not found"
// *Cause: A foreign key value has no matching primary key value.
// *Action: Delete the foreign key or add a matching primary key.

如果捕获到异常ORA-02291则输出：外键取值错误；

declare
  myerr exception;
  pragma exception_init(myerr,-2291);
  v_ename emp.ename%type;
  v_sal emp.sal%type;
  v_err number;
begin
  update emp set deptno=80 where empno=7839;
  select ename,sal into v_ename,v_sal from emp where deptno=&p_deptno;
  v_err:=0;
    dbms_output.put_line(v_err);
exception
  when no_data_found then
    v_err:=-1;
    dbms_output.put_line(v_err);
  when too_many_rows then
    dbms_output.put_line('查询返回太多行');
  when myerr then
    dbms_output.put_line('外键取值错误');
end;
/

练习4-综合练习

    获取部门编号为1的员工姓名

    SCOTT@testdb>select ename from emp where empno=1;

    no rows selected

    删除部门表中所有的行

    SCOTT@testdb>delete dept;
    delete dept
    *
    ERROR at line 1:
    ORA-02292: integrity constraint (SCOTT.FK_DEPTNO) violated - child record found

    更新员工表中部门编号为7839的部门编号，手动输入

    打印员工表中部门编号为手动输入的编号的员工工资

/* 异常处理的作用 */
declare
  v_sal number;
begin
  declare
    myerr exception;
    pragma exception_init(myerr,-2292);
    v_deptno number:=&p_deptno;
    v_ename varchar2(10);
  begin
   select ename into v_ename from emp where empno=1;/* 因为不存在empno=1的行，该行会触发异常no_data_found */
    delete dept;/* dept表存在外键，该动作会会触发异常 ORA-02292*/
    update emp set deptno=v_deptno where empno=7839;
  exception
    when myerr then
      dbms_output.put_line('ORA-02292');
    when others then
      dbms_output.put_line('unknown error');  
      dbms_output.put_line(sqlcode||' ; '||sqlerrm);  
  end;
  select sal into v_sal from emp where empno=&p_empno;
  dbms_output.put_line(v_sal);
end;
/

出现异常时不会继续往下执行，会跳出当前块，因此delete	和update语句都没有执行；而select sal into v_sal from emp where empno=&p_empno;语句执行成功。

运行结果

Enter value for p_deptno: 1
old   7:     v_deptno number:=&p_deptno;
new   7:     v_deptno number:=1;
Enter value for p_empno: 8000
old  20:   select sal into v_sal from emp where empno=&p_empno;
new  20:   select sal into v_sal from emp where empno=8000;
unknown error
100 ; ORA-01403: no data found
1888

PL/SQL procedure successfully completed.

我们调整一下代码

/* 异常处理的作用 */
declare
  v_sal number;
begin
  declare
    myerr exception;
    pragma exception_init(myerr,-2292);
    v_deptno number:=&p_deptno;
    v_ename varchar2(10);
  begin
    delete dept;/* dept表存在外键，该动作会会触发异常 ORA-02292*/
    update emp set deptno=v_deptno where empno=7839;
  exception
    when myerr then
      dbms_output.put_line('ORA-02292');
    when others then
      dbms_output.put_line('unknown error');  
      dbms_output.put_line(sqlcode||' ; '||sqlerrm);  
  end;
  select sal into v_sal from emp where empno=&p_empno;
  dbms_output.put_line(v_sal);
end;
/

执行结果

Enter value for p_deptno: 1
old   7:     v_deptno number:=&p_deptno;
new   7:     v_deptno number:=1;
Enter value for p_empno: 8000
old  19:   select sal into v_sal from emp where empno=&p_empno;
new  19:   select sal into v_sal from emp where empno=8000;
ORA-02292
1888

成功触发了ORA-02292异常。
练习5-处理自定义异常

/* 使用自定义异常 */
declare
  myerr exception;
  pragma exception_init(myerr,-20000);
  v_empno number:=&p_empno;
  v_sal number:=&p_sal;
begin
  if v_sal<1000 then
    raise_application_error(-20000,'自定义错误！');
  else
    update emp set sal=v_sal where empno=v_empno;
  end if;
exception
  when myerr then
    dbms_output.put_line('工资太少!');
end;
/


PLSQL-命名块-触发器

触发器概述

像存储过程一样，触发器是一个命名的PL / SQL单元，它存储在数据库中并且可以重复调用。与存储过程不同，可以启用和禁用触发器，但是不能显式调用它。

一种 触发器 就像一个存储过程，一旦发生指定事件，Oracle数据库就会自动调用该过程。

    注意： 该数据库只能检测系统定义的事件。您无法定义自己的事件。

PL/SQL Triggers
使用触发器的原因

触发器使您可以自定义数据库管理系统。例如，您可以使用触发器来：

    自动生成虚拟列值

    记录事件

    收集表访问的统计信息

    针对视图发出DML语句时修改表数据

    当子表和父表位于分布式数据库的不同节点上时，强制引用完整性

    发布有关数据库事件，用户事件和SQL语句的信息以订阅应用程序

    在正常工作时间后阻止对表执行DML操作

    防止无效交易

    强制执行您无法使用约束定义的复杂业务或参照完整性规则（请参阅“触发器和约束如何不同”）

触发器和约束有何不同

触发和 约束可以约束数据输入，但是它们有很大的不同。

触发器始终仅适用于新数据。例如，触发器可以阻止DML语句将NULL值插入数据库列中，但是该列可能包含NULL在定义触发器之前或禁用触发器时插入到该列中的值。

约束可以仅应用于新数据（如触发器），也可以应用于新数据和现有数据。约束行为取决于约束状态，如《Oracle数据库SQL语言参考》中所述。

与强制执行相同规则的触发器相比，约束更易于编写且不易出错。但是，触发器可以强制执行某些约束无法执行的复杂业务规则。Oracle强烈建议您仅在以下情况下使用触发器来限制数据输入：

当子表和父表位于分布式数据库的不同节点上时，强制实施引用完整性

强制执行无法使用约束定义的复杂业务或参照完整性规则
触发器的分类

    如果触发器是在表或视图上创建的，则触发事件由DML语句组成，该触发器称为DML触发器。有关更多信息，请参见“ DML触发器”。
    如果触发器是在模式或数据库上创建的，则触发事件由DDL或数据库操作语句组成，并且该触发器称为系统触发器。有关更多信息，请参见“系统触发器”。

何时触发

    Before 在条件运行前，执行触发器

    After 在条件运行后，执行触发器

    INSTEAD OF 替代触发，作用在视图上

DML触发器

DML触发器可以是简单的也可以是复合的。

一种 简单的DML触发器正是在其中之一触发时间点：

    在触发语句运行之前

    （该触发器称为BEFORE 语句触发器或语句级 BEFORE 触发器。）

    触发语句运行后

    （该触发器称为AFTER 语句触发器或语句级 AFTER 触发器。）

    触发语句影响的每一行之前

    （该触发器称为BEFORE 每行触发器或行级 BEFORE 触发器。）

    在触发语句影响的每一行之后

    （该触发器称为AFTER 每行触发器或行级 AFTER 触发器。）

用于检测触发DML语句的条件谓词

DML触发器的触发事件可以由多个触发语句组成。当其中之一触发触发器时，触发器可以通过使用条件谓词：
条件谓词 	当且仅当以下情况为真：
INSERTING 	一条INSERT语句触发了触发器。
UPDATING 	一条UPDATE语句触发了触发器。
UPDATING ('column') 	UPDATE影响指定列的语句触发了触发器。
DELETING 	一条DELETE语句触发了触发器。

条件谓词可以出现在BOOLEAN表达式可以出现的任何位置。
构建实验表

connect scott/tiger
drop table d purge;
drop table e purge;
create table d as select * from dept;
create table e as select * from emp;
select * from d;
Select * from e;

创建触发器-After

    当 D 表的部门号修改的时候 E 表的对应部门号也相应的修改

    当 D 表的某个部门号删除的时候，E 表的对应部门同时被删除

create or replace trigger d_update
after
delete or update of deptno on d
for each row
begin
--当 D 表的部门号修改的时候 E 表的对应部门号也相应的修改
	if (updating and :old.deptno != :new.deptno)
	then
		update e set deptno =: new.deptno where deptno = :old.deptno;
	end if;
--当 D 表的某个部门号删除的时候，E 表的对应部门同时被删除
	if deleting
	then
		delete e where deptno = :old.deptno;
	end if;
end;
/

验证触发器的功能

update d set deptno=50 where deptno=30; select * from e;
select * from d;
delete d where deptno=20;
select * from e;
select * from d;
Commit;

创建触发器-Before

    禁止对表 E 的 SAL 列进行修改；

    一旦发现有对该列的update操作则报错。

禁止对表 E 的 SAL 列进行修改
create or replace trigger e_update
before update of sal on e
begin
if updating then raise_application_error(-20001,'工资不能被改动'); end if;
end;
/

管理触发器

查看触发器状态

select trigger_name, status from user_triggers;

禁用某个触发器

alter trigger d_update disable;

禁用表的所有触发器

alter table d disable all triggers;

删除触发器

drop trigger d_update;

系统触发器

一种 系统触发器是在架构或数据库上创建的。它的触发事件是由任一DDL语句（中列出的“ ddl_event ”）或数据库操作的语句（中列出“ database_event ”）。

系统触发了其中之一 时间点：

    在触发语句运行之前

    （该触发器称为BEFORE 语句触发器或语句级 BEFORE 触发器。）

    触发语句运行后

    （该触发器称为AFTER 语句触发器或语句级 AFTER 触发器。）

    代替触发CREATE语句

    （该触发器称为INSTEAD OF CREATE 触发器。）

建立一个登录的审计触发器
构建实验表 login_table

conn scott/tiger
drop table login_table;
create table login_table(user_id varchar2(15),log_date date,action varchar2(15));

创建登陆后的触发动作 logon_trig

--on schema 方式为只记录当前的用户行为
CREATE OR REPLACE TRIGGER logon_trig
AFTER LOGON ON SCHEMA
BEGIN
INSERT INTO login_table(user_id, log_date, action)
VALUES (USER, SYSDATE, 'Logging on');
END;
/

创建退出前的触发动作 logoff_trig

CREATE OR REPLACE TRIGGER logoff_trig
BEFORE LOGOFF ON SCHEMA
BEGIN
INSERT INTO login_table(user_id, log_date, action) VALUES (USER, SYSDATE, 'Logging off');
END; /

验证触发器

conn scott/tiger
conn hr/hr
conn scott/tiger
select user_id, to_char(log_date,'yyyy/mm/dd:hh24:mi:ss') log_date, action from login_table;

删除触发器

drop trigger logon_trig;
drop trigger logoff_trig;


PLSQL-命名块-函数

通过 PL / SQL 实现自定义函数，注意：函数一定要有返回值！
创建自定义函数语法

create or replace function tax(p_sal number)
return number
is
begin
  return p_sal*0.05;
end;
/

使用自定义函数

select ename,sal,tax(sal) from emp;

实践
实践1-根据工资等级交税

要求：

    按照以下等级交税

grade 1 --> 0
grade 2 --> 0.05
grade 3 --> 0.07
grade 4 --> 0.1
grade 5 --> 0.12

create or replace function tax(p_sal number)
return number
is
  v_grade number;
  v_tax number;
begin
  select grade into v_grade from salgrade where p_sal between losal and hisal;
  v_tax := case v_grade when 1 then 0
                        when 2 then p_sal*0.05
                        when 3 then p_sal*0.07
                        when 4 then p_sal*0.1
                        when 5 then p_sal*0.05
          else null end;
  return v_tax;
end;
/

实践2-获取指定部门的工资总和

create or replace function subtotal(p_deptno number)
return number
is
  v_total number;
begin
  select sum(sal) into v_total from emp where deptno=p_deptno;
  return v_total;
end;
/

实践3-使用函数校验部门存在否

    校验部门存在否
    return boolean

create or replace function valid_deptno(p_deptno number)
return boolean
is
  v number;
begin
  select 1 into v from dept where deptno=p_deptno;
  return true;
exception
  when no_data_found then
    return false;
end;
/

实践4-部门存在才可以添加新雇员

create or replace procedure add_emp
(p_ename emp.ename%type,
p_job emp.job%type default 'CLERK',
p_mgr emp.mgr%type default 7698,
p_hiredate date default sysdate,
p_sal emp.sal%type default 1000,
p_comm emp.comm%type default null,
p_deptno emp.deptno%type default 30
)
is
begin
  if valid_deptno(p_deptno) then
  insert into emp values
(seq_empno.nextval,
p_ename,
p_job,
p_mgr,
p_hiredate,
p_sal,
p_comm,
p_deptno);
  else
    raise_application_error(-20000,'部门不存在');
  end if;
end;
/

create or replace function get_ename
(p_empno number,
p_ename out varchar2)
return number
is
  v_sal number;
begin
  select ename,sal into p_ename,v_sal from emp where empno=p_empno;
  return v_sal;
end;
/

var g_ename varchar2(10)
var g_sal number
exec :g_sal :=get_ename(7369,:g_ename);

实践4-确定性函数（确定返回值函数）

create or replace function test_wait
(p_char varchar2)
return varchar2
is
begin
  dbms_lock.sleep(1);
  return p_char;
end;
/

select * from t01 where test_wait(x)='A';

create or replace function test_wait_2
(p_char varchar2)
return varchar2 deterministic
is
begin
  dbms_lock.sleep(1);
  return p_char;
end;
/

存储过程procedure

定义存储过程

create or replace procedure add_sal
is
  --变量声明
begin
  update emp set sal=sal*1.1;
end;
/

调用存储过程

begin
  add_sal;
end;
/

execute add_sal;
exec add_sal;

执行结果

SQL> create or replace procedure booboo
  2  is
  3  begin
  4  dbms_output.put_line('+++++++');
  5  end;
  6  /

  SQL> begin
    2  booboo;
    3  end;
    4  /
  +++++++

  PL/SQL procedure successfully completed.

  SQL> execute booboo;
  +++++++

  PL/SQL procedure successfully completed.

  SQL> exec booboo;
  +++++++

  PL/SQL procedure successfully completed.

实践
实践1-带有导入型形式参数

根据雇员编号涨工资

create or replace procedure add_sal
(p_empno number,p_sal number)
is
  v_old_sal emp.sal%type;
begin
  select sal into v_old_sal from emp where empno=p_empno;
  if p_sal<v_old_sal or p_sal is null then
    raise_application_error(-20000,'工资不能减少');
  else
    update emp set sal=p_sal where empno=p_empno;
  end if;
end;
/
exec add_sal(7369,700);
drop procedure add_sal;

查看程序源代码：

select text from user_source where name='ADD_SAL';

实践2-带有导出型形式参数的

    编写匿名块进行测试

/* 测试 */
declare
  v_empno emp.empno%type:=&p_empno;
  v_ename emp.ename%type;
  v_sal emp.sal%type;
begin
  select ename,sal into v_ename,v_sal from emp where empno=v_empno;
  dbms_output.put_line(v_ename||' '||v_sal);
end;
/

    创建存储过程 get_ename

/* 创建存储过程 get_ename */
create or replace procedure get_ename
(p_empno in emp.empno%type,
p_ename out emp.ename%type,
p_sal out emp.sal%type)
is
begin
  select ename,sal into p_ename,p_sal from emp where empno=p_empno;
end;
/

    调用存储过程

调用方法1:

declare
  g_ename emp.ename%type;
  g_sal emp.sal%type;
begin
  get_ename(7900,g_ename,g_sal);
  dbms_output.put_line(g_ename||' '||g_sal);
end;
/

调用方法2:

var g_ename varchar2(10)
var g_sal number
exec get_ename(7900,:g_ename,:g_sal);

实践3-导入/导出型的形式参数

create or replace procedure get_emp
(g_test in out varchar2)
is
begin
 select ename into g_test from emp where empno=g_test;
end;
/

declare
  v1 varchar2(10):=7839;
begin
  get_emp(v1);
  dbms_output.put_line(v1);
end;
/

实践4-带有default值的形式参数

create or replace procedure add_emp
(p_ename emp.ename%type,
p_job emp.job%type default 'CLERK',
p_mgr emp.mgr%type default 7698,
p_hiredate date default sysdate,
p_sal emp.sal%type default 1000,
p_comm emp.comm%type default null,
p_deptno emp.deptno%type default 30)
is
begin
  insert into emp values
(seq_empno.nextval,
p_ename,
p_job,
p_mgr,
p_hiredate,
p_sal,
p_comm,
p_deptno);
end;
/

形参赋值

形参赋值的位置表示法：

exec add_emp('Tom','SALESMAN');

形参赋值的名称表示法：

exec add_emp(p_ename=>'Tom',p_job=>'SALESMAN',p_deptno=>20);

形参赋值的混合表示法：

exec add_emp('Tom','SALESMAN',p_sal=>2000,p_mgr=>7839);

存储过程中的事务处理风格

create or replace procedure add_sal
(p_empno number,p_sal number)
is
  v_old_sal emp.sal%type;
begin
  select sal into v_old_sal from emp where empno=p_empno;
  if p_sal<v_old_sal or p_sal is null then
    raise_application_error(-20000,'工资不能减少');
  else
    update emp set sal=p_sal where empno=p_empno;
    commit;
  end if;
end;
/

自治事务

create or replace procedure add_sal
(p_empno number,p_sal number)
is
  pragma autonomous_transaction;
  v_old_sal emp.sal%type;
begin
  select sal into v_old_sal from emp where empno=p_empno;
  if p_sal<v_old_sal or p_sal is null then
    raise_application_error(-20000,'工资不能减少');
  else
    update emp set sal=p_sal where empno=p_empno;
    commit;
  end if;
end;
/

调用者模式

create or replace procedure add_sal
(p_empno number,p_sal number)
authid current_user
is
  pragma autonomous_transaction;
  v_old_sal emp.sal%type;
begin
  select sal into v_old_sal from emp where empno=p_empno;
  if p_sal<v_old_sal or p_sal is null then
    raise_application_error(-20000,'工资不能减少');
  else
    update emp set sal=p_sal where empno=p_empno;
    commit;
  end if;
end;
/

declare
  v_empno number;
  v_time timestamp;
begin
  delete emp where empno=7369
  returning empno,current_timestamp into v_empno,v_time;
  dbms_output.put_line(v_empno||' '||v_time);
end;
/

动态sql语句

create or replace procedure test_create
(t_name varchar2)
is
  v_sql varchar2(1000);
begin
  v_sql:='create table '||t_name||' (x int)';
  execute immediate v_sql;
end;
/

declare
  p_deptno number:=50;
  p_dname varchar2(10):='APP';
  p_loc varchar2(13):='BJ';
begin
  execute immediate 'insert into dept values (:1,:2,:3)' using p_deptno,p_dname,p_deptno;
end;
/

create or replace procedure test_create
(v_sql varchar2)
is
begin
  execute immediate v_sql;
end;
/

包Package

什么是包

PL/SQL Packages

一种 包是一个架构对象，将逻辑上相关的PL / SQL类型，变量，常量，子程序，游标和异常进行分组。包被编译并存储在数据库中，许多应用程序可以在其中共享其内容。您可以将包裹视为应用。

一个包总是有一个 规范，它声明可以从包外部引用的公共项目。您可以将软件包规范视为应用程序编程接口（API）。有关包装规格的更多信息，请参见“包装规格”。

如果公共项包括游标或子程序，则该程序包还必须包含一个 身体。该主体必须为公共游标定义查询，并为公共子程序定义代码。主体还可以声明和定义私有项目，这些私有项目不能从包装外部引用，但是对于包装的内部工作而言是必需的。最后，主体可以具有一个初始化部分，一个语句来初始化变量并执行其他一次性设置步骤以及一个异常处理部分。您可以更改正文，而无需更改规范或对公共项的引用；因此，您可以将包装体视为黑匣子。有关包主体的更多信息，请参见“包主体”。

在程序包规范或程序包主体中，可以使用以下命令将程序包子程序映射到外部Java或C子程序： 调用规范，它将外部子程序名称，参数类型和返回类型映射到它们的SQL副本。有关详细信息，请参见“函数声明和定义”和“过程声明和定义”。

程序包规范的AUTHID 子句确定程序包中的子程序和游标是否以其定义程序（默认值）或调用程序的特权运行，以及是否在定义程序或调用程序的模式中解析了它们对架构对象的不合格引用。有关更多信息，请参见“调用者的权利和定义者的权利（AUTHID属性）”。
为什么使用包

软件包通过以下内容支持开发和维护可靠的可重用代码 特征：
模块化

包使您可以在命名的PL / SQL模块中封装与逻辑相关的类型，变量，常量，子程序，游标和异常。您可以使每个程序包易于理解，并使程序包之间的接口简单，清晰且定义明确。这种做法有助于应用程序开发。
简化应用设计

设计应用程序时，最初需要的只是包装规格中的接口信息。您可以在没有规范的情况下编写和编译规范。接下来，您可以编译引用程序包的独立子程序。在准备好完成应用程序之前，无需完全定义包主体。
信息隐藏

包使您可以在包规范中共享接口信息，并在包主体中隐藏实现细节。将实现细节隐藏在正文中具有以下优点：

您可以在不影响应用程序界面的情况下更改实施细节。

应用程序用户无法开发依赖于您可能想要更改的实现详细信息的代码。
新增功能

包公共变量和游标可以在会话的整个生命周期中持续存在。它们可以由环境中运行的所有子程序共享。它们使您可以跨事务维护数据，而无需将其存储在数据库中。（对于在程序包的生命周期内程序包公共变量和游标不持久的情况，请参阅“程序包状态”。）
更好的性能

首次调用程序包子程序时，Oracle数据库会将整个程序包加载到内存中。随后在同一软件包中调用其他子程序不需要磁盘I / O。

软件包可防止级联依赖性和不必要的重新编译。例如，如果更改包函数的主体，则Oracle数据库不会重新编译调用该函数的其他子程序，因为这些子程序仅取决于规范中声明的参数和返回值。
创建包的语法

CREATE PACKAGE Statement

CREATE [ OR REPLACE ] PACKAGE [ schema. ] package_name
   [ invoker_rights_clause ]
   { IS | AS } item_list_1 END [ package_name ] ;

CREATE PACKAGE BODY Statement

CREATE [ OR REPLACE ] PACKAGE BODY [ schema. ] package_name
{ IS | AS } declare_section [ initialize_section ]
END [ package_name ] ;

实践

create or replace package pk1
is
procedure add_emp
(p_ename emp.ename%type,
p_job emp.job%type default 'CLERK',
p_mgr emp.mgr%type default 7698,
p_hiredate date default sysdate,
p_sal emp.sal%type default 1000,
p_comm emp.comm%type default null,
p_deptno emp.deptno%type default 30);
procedure get_ename
(p_empno in emp.empno%type,
p_ename out emp.ename%type,
p_sal out emp.sal%type);
procedure get_ename
(p_ename emp.ename%type,
p_job out emp.job%type,
p_hiredate out emp.hiredate%type);
procedure add_sal
(p_empno number,p_sal number);
end;
/

create or replace package body pk1
is
function valid_deptno
(p_deptno number)
return boolean
is
  v number;
begin
  select 1 into v from dept where deptno=p_deptno;
  return true;
exception
  when no_data_found then
    return false;
end;
procedure get_ename
(p_empno in emp.empno%type,
p_ename out emp.ename%type,
p_sal out emp.sal%type)
is
begin
  select ename,sal into p_ename,p_sal from emp where empno=p_empno;
end;
procedure get_ename
(p_ename emp.ename%type,
p_job out emp.job%type,
p_hiredate out emp.hiredate%type)
is
begin
  select job,hiredate into p_job,p_hiredate from emp where ename=p_ename;
end;
procedure add_sal
(p_empno number,p_sal number)
is
  v_old_sal emp.sal%type;
begin
  select sal into v_old_sal from emp where empno=p_empno;
  if p_sal<v_old_sal or p_sal is null then
    raise_application_error(-20000,'工资不能减少');
  else
    update emp set sal=p_sal where empno=p_empno;
  end if;
end;
procedure add_emp
(p_ename emp.ename%type,
p_job emp.job%type default 'CLERK',
p_mgr emp.mgr%type default 7698,
p_hiredate date default sysdate,
p_sal emp.sal%type default 1000,
p_comm emp.comm%type default null,
p_deptno emp.deptno%type default 30)
is
begin
  if valid_deptno(p_deptno) then
  insert into emp values
(seq_empno.nextval,
p_ename,
p_job,
p_mgr,
p_hiredate,
p_sal,
p_comm,
p_deptno);
  else
    raise_application_error(-20000,'部门不存在');
  end if;
end;
end;
/

